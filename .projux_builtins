###############################################################################
# Copyright 2012-2013 Mike Dreves
#
# All rights reserved. This program and the accompanying materials
# are made available under the terms of the Eclipse Public License v1.0
# which accompanies this distribution, and is available at:
#
#  http://opensource.org/licenses/eclipse-1.0.php
#
# By using this software in any fashion, you are agreeing to be bound
# by the terms of this license. You must not remove this notice, or any
# other, from this software. Unless required by applicable law or agreed
# to in writing, software distributed under the License is distributed
# on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
# either express or implied.
###############################################################################

################################################################################
# Project command.
#
# REQUIREMENTS: project entries have been added to ~/.projects
#
# Examples:
#   project              # show current project
#   project ls           # show all known projects
#   project foo          # if attached switch to foo, if detached init foo vars
#   project attach       # attach to tmux for current project
#   project attach 2     # attach/switch to 2nd session for current project
#   project attach foo   # attach/switch to foo project
#   project attach foo 3 # attach/switch to 3rd session for project foo
#   project detach       # detach cur client from cur project
#   project detach foo   # detach all clients attached to foo project
#   project detach foo 2 # detach all clients attached to 2nd session to foo
#   project kill         # kill all of current project's tmux sessions
#   project kill foo     # kill all of foo project's tmux sessions
#   project kill foo 1   # kill main session of project foo
#   project kill foo 2   # kill 2nd session of project foo
#   project sessions     # show all attached project sessions
#   project settings     # show project env var settings
#   project settings foo # show project foo's env var settings
#   project clear        # clear current project vars
#   project sync         # syncs local files with remote project host
#   project sync foo     # syncs local files with foo's project host
#   project backup       # backs up changed project files to PROJECT_BACKUP_DIR
#   project backup foo   # backup changed proj foo files to PROJECT_BACKUP_DIR
#   project companion    # show companion group session assoc with cur session
#
# Args:
#   $* (optional): ls
#                  <project_name> [<instance>]
#                  attach [<project_name>] [<instance>]
#                  detach [<project_name>] [<instance>]
#                  kill [<project_name>] [<instance>]
#                  sessions
#                  settings [<project_name>]
#                  clear
#                  sync [<project_name>]
#                  backup [<project_name>]
#                  companion [<project_name>] [<instance>]
################################################################################
function project() {
  shopt -q nocasematch
  local orig_nocasematch=$?
  shopt -s nocasematch

  local cur_session=$(tmux display-message -p "#S" 2> /dev/null)
  if [[ $# -eq 0 ]]; then
    if [[ -n "${cur_session}" ]]; then
      echo "${cur_session} (attached)"
    else
      echo "${PROJECT_NAME}"
    fi
    return 0
  elif [[ "${1}" == "ls" ]]; then
    __projux_project_ls
    return 0
  elif [[ "${1}" == "sessions" ]]; then
    tmux ls -F"#{session_name}"
    return 0
  elif [[ "${1}" == "clear" ]]; then
    __projux_clear_vars "${PROJECT_NAME}"
    return 0
  fi

  # Remaining commands require project name
  local project_name="${PROJECT_NAME-$(__projux_default_project)}"
  local instance=""
  if [[ "${1}" == "attach" || "${1}" == "detach" || "${1}" == "kill" || \
      "${1}" == "settings" || "${1}" == "backup" || "${1}" == "sync" || \
      "${1}" == "companion" ]]; then
    if [[ -n "${2}" ]]; then
      if [[ "${2}" =~ ^[0-9]+$ ]]; then
        instance="${2}"  # e.g. xxx 2
      else
        project_name="${2}" # e.g. xxx foo
        if [[ -n "${3}" ]]; then
          instance="${3}"  # e.g. xxx foo 2
        fi
      fi
    elif [[ "${cur_session}" =~ _[0-9]+$ ]]; then
      instance="${cur_session:${#cur_session}-1}" # default project/instance
    fi
  elif [[ -n "${1}" ]]; then
    if [[ "${1}" =~ _[0-9]+$ ]]; then  # foo_2
      project_name="${1:0:${#1}-2}"  # foo
      instance="${1:${#1}-1}"  # 2
    else
      project_name="${1}"  # foo
      if [[ "${2}" =~ ^[0-9]+$ ]]; then
        instance="${2}"  # e.g. foo 2
      fi
    fi
  fi

  # Validate the project exists
  if ! __projux_project_exists "${project_name}"; then
    local msg
    msg="Project entry for '${project_name}' not found in ~/.projects"
    echo "$(tput setaf 1)${msg}$(tput sgr0)"
    if [[ $orig_nocasematch -eq 1 ]]; then shopt -u nocasematch; fi
    return 1
  fi

  # Session id is used by many commands, save it in var
  if [[ -z "${instance}" || "${instance}" == "1" ]]; then
    local session="${project_name}"
  else
    local session="${project_name}_${instance}"
  fi

  if [[ "${1}" == "companion" ]]; then
    if [[ -z "${instance}" ]]; then
      echo "${project_name}_2"
    else
      echo "${project_name}"
    fi
  elif [[ "${1}" == "settings" ]]; then
    __projux_project_settings "${project_name}"
  elif [[ "${1}" == "backup" ]]; then
    __projux_project_backup "${project_name}"
  elif [[ "${1}" == "sync" ]]; then
    __projux_project_sync "${project_name}"
  elif [[ "${1}" == "refresh" ]]; then
    clean
    compile
  elif [[ "${1}" == "attach" && -z "${cur_session}" ]]; then
    # Connect to project (this handles cases where we are already in project)
    env_vars=$(__projux_project_vars "${project_name}")
    # Always set projects vars before cmd (may be a project specific host set)
    eval "${env_vars} __projux_project_attach ${project_name} ${instance}"
  elif [[ "${1}" == "detach" ]]; then
    if [[ -z "${2}" ]]; then
      tmux detach  # no session specified, only detach this client
    else
      tmux detach -s "${session}"  # detach all clients attach to passed session
    fi
  elif [[ "${1}" == "kill" ]]; then
    if [[ ! "${2}" =~ [0-9] && ! "${3}" =~ [0-9] ]]; then
      # Kill sub-sessions too
      for s in `tmux ls -F"#{session_name}" | grep ${project_name}`; do
        # Don't kill cur session or will lose session before sub-sessions killed
        if [[ "${cur_session}" != "${s}" ]]; then
          tmux kill-session -t "${s}"
        fi
      done
    fi
    tmux kill-session -t "${session}" &> /dev/null
  else
    if [[ -z "${cur_session}" ]]; then
      if [[ -n "${instance}" ]]; then
        local msg="ERROR: Must be attached to use multiple project instances"
        echo "$(tput setaf 1)${msg}$(tput sgr0)"
        return 1
      else
        # Not attached, just init proj
        __projux_project_init "${project_name}"
      fi
    else
      # Currently attached, switch projects
      env_vars=$(__projux_project_vars "${project_name}" 1)
      # Always set projects vars before cmd (may be a project specific host set)
      eval "${env_vars} __projux_project_attach ${project_name} ${instance}"
    fi
  fi

  if [[ $orig_nocasematch -eq 1 ]]; then shopt -u nocasematch; fi

  return 0
}

################################################################################
# Selects/creates tmux window in current project.
#
# REQUIREMENTS: project attached (via 'project attach').
#
# Examples:
#   win                     # display current window
#   win ls                  # list windows
#   win new foo             # create new window
#   win session             # list window assoc with session (foo_2 => 2)
#   win bash                # switch to bash window
#   win repl                # switch to repl window
#
# Args:
#   $* [new] <window_name>
################################################################################
function win() {
  if [[ "${1}" == "session" ]]; then
    shift
    local session=$(tmux display-message -p "#S" 2> /dev/null)
    local win_num=${session##*_}
    if [[ "${win_num}" == "${session}" ]]; then
      local win_num=1
    fi
  else
    local win_num=$(tmux display-message -p "#I" 2> /dev/null)
  fi

  # no tmux sessions, exit
  if [[ -z "${win_num}" ]]; then
    return 1
  fi

  local win_name=$(\
      tmux list-windows | grep ${win_num}":" | awk '{print $2}')

  if [[ -z "${1}" ]]; then
    echo "${win_name}"
    return
  fi

  if [[ "${1}" == "ls" ]]; then
    tmux list-windows | awk '{print $2}'
  elif [[ "${1}" == "new" ]]; then
    shift
    tmux new-window -d -n "$*" 'bash; stty -ixon'
  else
    tmux select-window -t "$*"
  fi
}

################################################################################
# Selects/creates tmux pane in current project.
#
# REQUIREMENTS: project attached (via 'project attach').
#
# Examples:
#   pane                    # display current pane
#   pane ls                 # list panes
#   pane new                # create new horizontal pane
#   pane split              # create new horizontal pane
#   pane vsplit             # create new vertial pane
#   pane 3                  # switch to pane 3  (ctrl-a o)
#   pane %5                 # switch to pane with global id 5
#
# Args:
#   $* [new] <window_name>
################################################################################
function pane() {
  local pane_num=$(tmux display-message -p "#P")
  local global_pane_num=$(\
      tmux list-panes | grep "${pane_num}"":" | awk '{print $7}')

  if [[ -z "${1}" ]]; then
    echo "${pane_num} (global: ${global_pane_num})"
    return
  fi

  if [[ "${1}" == "ls" ]]; then
    tmux list-panes | \
        awk '{print substr($1,0,1) " (global: " $7 ")"}'
  elif [[ "${1}" == "new" || "${1}" == "split" ]]; then
    tmux split-window -d
  elif [[ "${1}" == "vsplit" ]]; then
    tmux split-window -d -h
  else
    tmux select-pane -t "$*"
  fi
}

################################################################################
# SSH to project host
################################################################################
function pssh() {
  host=${PROJECT_HOST-${DEFAULT_PROJECT_HOST}}
  if __projux_is_project_local; then
    host=${DEFAULT_PROJECT_HOST}
  fi
  ssh -Y -t ${host}
}

################################################################################
# SFTP to project host
################################################################################
function psftp() {
  host=${PROJECT_HOST-${DEFAULT_PROJECT_HOST}}
  if __projux_is_project_local; then
    host=${DEFAULT_PROJECT_HOST}
  fi
  sftp ${host}
}

################################################################################
# Project based vim
#
# Starts vim as follows:
#   vim --servername ${PROJECT_NAME} -c ":Open :session $PROJECT_NAME"
################################################################################
function pvim() {
  if [[ $# -gt 0 ]]; then
    vim --servername $PROJECT_NAME $*
  else
    vim --servername $PROJECT_NAME -c ":Open :session"
  fi
}

################################################################################
# Internal Helper Functions
################################################################################

################################################################################
# Sends text to tmux window/pane (internal use).
#
# If PROXY_CMDS is true (default) then any calls made on non-dev machine will
# be proxied to the dev machine.
#
# REQUIREMENTS: project env vars are properly set (via 'project <name>')
#
# Example:
#   __projux_tmux_send foo:bash ls
#
# Args:
#   $1: Tmux window/pane name (e.g. session:win or session:win.pane)
#   $*: Text
################################################################################
function __projux_tmux_send() {
  if __projux_is_project_local; then
    tmux set-buffer "${@:2}$(printf \\r)"
    tmux paste-buffer -d -t "${1}" &> /dev/null
  else
    __projux_ssh_send "__projux_tmux_send $*"
  fi
  return $?
}

################################################################################
# Sends cmd using ssh to project's host (internal use).
#
# If PROXY_CMDS is true (default) then any calls made on non-project host will
# be proxied to the project host machine.
#
# Example:
#   __projux_ssh_send ls
#
# Args:
#   $*: Command
################################################################################
function __projux_ssh_send() {
  if [[ ${PROXY_CMDS-false} -gt 0 ]]; then
    echo "$(tput setaf 1)ERROR: Not running on project host$(tput sgr0)"
    return 1
  else
    echo "$(tput setaf 3)WARNING: Not running on project host$(tput sgr0)"
    ssh -q -Y ${PROJECT_HOST-${DEFAULT_PROJECT_HOST}} "$*" 2> /dev/null
    return $?
  fi
}

################################################################################
# Returns $? == 0 if project is on local machine (internal use).
#
# REQUIREMENTS: project env vars are properly set (via 'project <name>')
################################################################################
function __projux_is_project_local() {
  if [[ "${PROJECT_HOST-${DEFAULT_PROJECT_HOST}}" == $(hostname)* || \
      "${PROJECT_HOST-${DEFAULT_PROJECT_HOST}}" == "${HOSTNAME}"* || \
      "${PROJECT_HOST-${DEFAULT_PROJECT_HOST}}" == "localhost" ]]; then
    return 0
  else
    return 1
  fi
}

################################################################################
# Returns default project name (internal use).
#
# The default tmux session is defined in this order:
#   * The current tmux session name matches a project in ~/.projects
#   * The first entry in ~/.projects
#   * "default"
################################################################################
function __projux_default_project() {
  local tmux_session=$(tmux display-message -p '#S' 2> /dev/null)
  if [[ -n "${tmux_session}" ]]; then
    if project ls | grep -q "${tmux_session}"; then
      echo "${tmux_session}"
      return
    fi
  fi

  # head -1 would be easier, but can get broken pipe errors
  local first=$(read -r line < <(project ls); echo $line)
  if [[ -n "$first" ]]; then
    echo "${first}"
  else
    echo "default"
  fi
}

################################################################################
# Returns default project tmux window name (internal use).
#
# If a project:win pair is passed then it is returned as is otherwise the
# default project window is looked up and returned along with the project as
# project:win. The default window is defined by the __projux_default_project and
# the first entry returned from the $DEFAULT_PROJECT_WINDOWS ist.
#
# Args:
#   $1: Project name (e.g. tmux session) or project:win pair.
################################################################################
function __projux_default_project_win() {
  local project_name="${1%%:*}"
  local project_win="${1#:*}"
  # If no ':' then project_win will be same as project_name
  if [[ "${project_win}" != "${project_name}" ]]; then
    echo "${1}"
  else
    local project_wins=$(\
        __projux_project_var "${project_name}" "PROJECT_WINDOWS")
    if [[ -z "${project_wins}" ]]; then
      project_wins="${DEFAULT_PROJECT_WINDOWS}"
    fi
    project_wins=$(echo ${project_wins}) # strip spaces
    # %%::* reads everything up to first :: (e.g. first window entry)
    project_win="${project_wins%%::*}"
    echo "${project_name}:${project_win}"
  fi
}

################################################################################
# Returns $? == 0 if project exists (internal use).
#
# Args:
#   $1: Project name.
################################################################################
function __projux_project_exists() {
  shopt -q nocasematch
  local orig_nocasematch=$?
  shopt -s nocasematch

  while read line; do
    if [[ "${line}" == "PROJECT_NAME"* && "${line:13}" == "${1}" ]]; then
      if [[ $orig_nocasematch -eq 1 ]]; then shopt -u nocasematch; fi
      return 0
    fi
  done < ~/.projects

  if [[ $orig_nocasematch -eq 1 ]]; then shopt -u nocasematch; fi
  return 1
}

################################################################################
# Project ls command (internal use - see project).
################################################################################
function __projux_project_ls() {
  while read line; do
    if [[ "${line}" == "PROJECT_NAME"* ]]; then
      echo "${line:13}"
    fi
  done < ~/.projects
}

################################################################################
# Returns list of project vars (A=B C=D etc) (internal use)
#
# Args:
#   $1: Project name
#   $2 (optional): 1 to not expand paths
################################################################################
function __projux_project_vars() {
  local project_name="${1}"
  local found=0
  local vars=()

 # Reset the defaults (these will be overridden if values are configured in
  # ~/.projects for this project, otherwise these defaults will take effect)
  vars+=("PROJECT_HOST=\"${DEFAULT_PROJECT_HOST}\"")
  vars+=("PROJECT_WINDOWS=\"${DEFAULT_PROJECT_WINDOWS}\"")
  vars+=("PROJECT_SHARE_DIR=\"${DEFAULT_PROJECT_SHARE_DIR}/${project_name}\"")
  vars+=("PROJECT_BACKUP_DIR=\"${DEFAULT_PROJECT_BACKUP_DIR}/${project_name}\"")
  vars+=("PROJECT_SYNC_LIST=\"${DEFAULT_PROJECT_SYNC_LIST}\"")
  vars+=("PROJECT_SYNC_DESTS=\"${DEFAULT_PROJECT_SYNC_DESTS}\"")
  if [[ -n "${DEFAULT_PROJECT_INCLUDE_FILTER}" ]]; then
    vars+=("PROJECT_INCLUDE_FILTER=\"${DEFAULT_PROJECT_INCLUDE_FILTER}\"")
  fi
  if [[ -n "${DEFAULT_PROJECT_EXCLUDE_FILTER}" ]]; then
    vars+=("PROJECT_EXCLUDE_FILTER=\"${DEFAULT_PROJECT_EXCLUDE_FILTER}\"")
  fi
  if [[ -n "${DEFAULT_PROJECT_FORMAT_CMDS}" ]]; then
    vars+=("PROJECT_FORMAT_CMDS=\"${DEFAULT_PROJECT_FORMAT_CMDS}\"")
  fi
  if [[ -n "${DEFAULT_PROJECT_LINT_CMDS}" ]]; then
    vars+=("PROJECT_LINT_CMDS=\"${DEFAULT_PROJECT_LINT_CMDS}\"")
  fi
  if [[ -n "${DEFAULT_PROJECT_COMPILE_CMDS}" ]]; then
    vars+=("PROJECT_COMPILE_CMDS=\"${DEFAULT_PROJECT_COMPILE_CMDS}\"")
  fi
  if [[ -n "${DEFAULT_PROJECT_TEST_CMDS}" ]]; then
    vars+=("PROJECT_TEST_CMDS=\"${DEFAULT_PROJECT_TEST_CMDS}\"")
  fi
  if [[ -n "${DEFAULT_PROJECT_COVERAGE_CMDS}" ]]; then
    vars+=("PROJECT_COVERAGE_CMDS=\"${DEFAULT_PROJECT_COVERAGE_CMDS}\"")
  fi
  if [[ -n "${DEFAULT_PROJECT_RUN_CMDS}" ]]; then
    vars+=("PROJECT_RUN_CMDS=\"${DEFAULT_PROJECT_RUN_CMDS}\"")
  fi
  if [[ -n "${DEFAULT_PROJECT_PACKAGE_CMDS}" ]]; then
    vars+=("PROJECT_PACKAGE_CMDS=\"${DEFAULT_PROJECT_PACKAGE_CMDS}\"")
  fi
  if [[ -n "${DEFAULT_PROJECT_DEPLOY_CMDS}" ]]; then
    vars+=("PROJECT_DEPLOY_CMDS=\"${DEFAULT_PROJECT_DEPLOY_CMDS}\"")
  fi
  if [[ -n "${DEFAULT_PROJECT_GENDOCS_CMDS}" ]]; then
    vars+=("PROJECT_GENDOCS_CMDS=\"${DEFAULT_PROJECT_GENDOCS_CMDS}\"")
  fi
  if [[ -n "${DEFAULT_PROJECT_SEARCH_CMDS}" ]]; then
    vars+=("PROJECT_SEARCH_CMDS=\"${DEFAULT_PROJECT_SEARCH_CMDS}\"")
  fi
  if [[ -n "${DEFAULT_PROJECT_FORMAT_FN}" ]]; then
    vars+=("PROJECT_FORMAT_FN=\"${DEFAULT_PROJECT_FORMAT_FN}\"")
  fi
  if [[ -n "${DEFAULT_PROJECT_LINT_FN}" ]]; then
    vars+=("PROJECT_LINT_FN=\"${DEFAULT_PROJECT_LINT_FN}\"")
  fi
  if [[ -n "${DEFAULT_PROJECT_COMPILE_FN}" ]]; then
    vars+=("PROJECT_COMPILE_FN=\"${DEFAULT_PROJECT_COMPILE_FN}\"")
  fi
  if [[ -n "${DEFAULT_PROJECT_TEST_FN}" ]]; then
    vars+=("PROJECT_TEST_FN=\"${DEFAULT_PROJECT_TEST_FN}\"")
  fi
  if [[ -n "${DEFAULT_PROJECT_COVERAGE_FN}" ]]; then
    vars+=("PROJECT_COVERAGE_FN=\"${DEFAULT_PROJECT_COVERAGE_FN}\"")
  fi
  if [[ -n "${DEFAULT_PROJECT_GETERRORS_FN}" ]]; then
    vars+=("PROJECT_GETERRORS_FN=\"${DEFAULT_PROJECT_GETERRORS_FN}\"")
  fi
  if [[ -n "${DEFAULT_PROJECT_GETURL_FN}" ]]; then
    vars+=("PROJECT_GETURL_FN=\"${DEFAULT_PROJECT_GETURL_FN}\"")
  fi
  if [[ -n "${DEFAULT_PROJECT_SANITY_FN}" ]]; then
    vars+=("PROJECT_SANITY_FN=\"${DEFAULT_PROJECT_SANITY_FN}\"")
  fi

  while read line; do
    if [[ "${line}" == "PROJECT_NAME=${project_name}" ]]; then
      local found=1
    elif [[ ${found} -eq 1 && "${line}" == "PROJECT_NAME="* ]]; then
      break
    fi
    if [[ ${found} -eq 1 && ! "${line}" == "#"* && ! "${line}" == "" ]] && \
        [[ "${line}" != alias* ]] && \
        [[ "${2}" == "" || ${2} =~ "${line%%=*}" ]]; then
      local var="${line%%=*}"
      local val="${line#*=}"
      if [[ "${val:0:1}" == '"' ]]; then
        vars+=("${var}=${val}")
      else
        vars+=("${var}=\"${val}\"")
      fi
    fi
  done < ~/.projects

  echo "${vars[@]}"
}

################################################################################
# Returns a specific project vars value (internal use)
#
# Args:
#   $1: Project name
#   $2: Project var name
################################################################################
function __projux_project_var() {
  local project_name="${1}"
  local var_name="${2}"
  # All project vars are passed prior to request specific var so that we can
  # fully resolve vars made up of other vars
  local project_vars=$(__projux_project_vars "${project_name}" 1)
  val=$(eval "${project_vars} eval echo '$""${var_name}""'")
  echo "${val}"
}

################################################################################
# Project settings command (internal use - see project).
#
# Args:
#   $1: Project name
################################################################################
function __projux_project_settings() {
  local project_name="${1}"
  local found=0
  local padding="                             "
  local project_vars=$(__projux_project_vars ${project_name} 1)
  local vars_echoed=()
  while read line; do
    if [[ "${line}" == "PROJECT_NAME=${project_name}" ]]; then
      local found=1
    elif [[ ${found} -eq 1 && "${line}" == "PROJECT_NAME="* ]]; then
      break
    fi
    if [[ ${found} -eq 1 && ! ${line} == "#"* && ! "${line}" == "" ]]; then
      local var="${line%%=*}"
      local val="${line#*=}"
      # Note: the ${project_vars} variable stores a space separated list of
      #   var=value env settings for the chosen project. By passing this
      #   list prior to calling echo we can resolve variables defined in
      #   terms of other variables on a project specific basis (e.g. without
      #   altering the current projects settings). However, we need to do a
      #   double eval and put the expand of value of $val in single quotes or
      #   else the current project values will override.
      if [[ ${val} == *"$"* && ! ${var} == alias* ]]; then
        val=$(eval "${project_vars} eval echo '""${val}""'")
      fi
      echo "${var}${padding:${#var}} : ${val}"
      vars_echoed+=("${var}")
    fi
  done < ~/.projects

  # Add missing defaults (only important ones)
  local defaults=("PROJECT_HOST" "PROJECT_WINDOWS")
  for def in "${defaults[@]}"; do
    found=0
    for var in "${vars_echoed[@]}"; do
      if [[ "${def}" == "${var}" ]]; then
        found=1
        break
      fi
    done
    if [[ ${found} -eq 0 ]]; then
      local val_name='$DEFAULT_'"${def}"
      local val=$(eval "echo $val_name")
      echo "${def}${padding:${#def}} : ${val}"
    fi
  done
}

################################################################################
# Clears all project vars.
#
# Args:
#   $1: Project name
################################################################################
function __projux_clear_vars() {
  local project_name="${1}"

  # Clear project specific vars
  while read line; do
    if [[ -z "${line}" || "${line}" == "#"* ]]; then
      continue
    fi
    if [[ "${line}" == "PROJECT_NAME=${project_name}" ]]; then
      local found=1
    elif [[ ${found} -eq 1 && "${line}" == "PROJECT_NAME="* ]]; then
      break
    fi
    if [[ ${found} -eq 1 ]]; then
      if [[ "${line}" == alias* ]]; then
        # 'unalias foo=bar' entries
        eval "un${line%%=*}" &> /dev/null
      else
        # variable definitions
        eval "unset ${line%%=*}" &> /dev/null
      fi
    fi
  done < ~/.projects

  unset PROJECT_LAST_OUT_DIR
}

################################################################################
# Project init (internal use - see project).
#
# Args:
#   $1: Project name
################################################################################
function __projux_project_init() {
  local project_name="${1}"

  # Reset the defaults (no values are set unless they are configured in
  # ~/.projects for this project, otherwise the defaults will take effect)
  __projux_clear_vars ${PROJECT_NAME}

  local found=0
  while read line; do
    if [[ -z "${line}" || "${line}" == "#"* ]]; then
      continue
    fi
    if [[ "${line}" == "PROJECT_NAME=${project_name}" ]]; then
      local found=1
    elif [[ ${found} -eq 1 && "${line}" == "PROJECT_NAME="* ]]; then
      break
    fi
    if [[ ${found} -eq 1 ]]; then
      if [[ "${line}" == alias* ]]; then
        # 'alias foo=bar' entries
        eval "${line}" &> /dev/null
      else
        # variable definitions
        local var=${line%%=*}
        local value=${line#*=}
        # make sure quoted
        if [[ "${value:0:1}" == '"' ]]; then
          eval "export ${line}" &> /dev/null
        else
          eval "export ${var}=\"${value}\"" &> /dev/null
        fi
      fi
    fi
  done < ~/.projects
}

################################################################################
# Attach/switch to local or remote project's tmux session (internal use).
#
# REQUIREMENTS: local and remote files to sync.
#
# By default the first session is created under the project name. Since it is
# desirable to support connecting more than one terminal to the same project
# session, an optional session instance may be provided that will create a new
# grouped session under the name <project>_<instance>.
#
# NOTE: By default sessions will try to attach to windows at the corresponding
#   (1-based) offset in PROJECT_WINDOWS (handled when projectrc sourced).
#
# For example, if project 'foo' has PROJECT_WINDOWS=bash::vim:: then:
#
#   project foo     # creates 'foo' session, opens win 'bash'
#   project foo 2   # creates 'foo_2' grouped session to 'foo', opens win 'vim'
#
# Args:
#   $1: Project name (e.g. main tmux session name)
#   $2 (optional): Session instance (e.g. group session number)
################################################################################
function __projux_project_attach() {
  local project_name="${1}"
  local instance_suffix=""
  if [[ -n "${2}" && ${2} -ne 1 ]]; then
    instance_suffix="_${2}"
  fi
  local session="${project_name}${instance_suffix}"

  # Get current session
  local cur_session=$(tmux display-message -p '#S' 2> /dev/null)

  if [[ "${session}" == "${cur_session}" ]]; then
    # Already in proper session, do nothing except reload vars
    __projux_project_init "${project_name}"
    return 0
  fi

  if tmux list-sessions 2> /dev/null | grep -q "${session}:"; then
    # Session we are attaching to exists, just switch
    local cmd="tmux switch -t ${session} &> /dev/null"
  else
    # Commands to create a new session
    local new_session=""
    local win
    eval "$(__projux_key_value_list kv_list ${PROJECT_WINDOWS})"
    for win in "${kv_list[@]}"; do
      cmd=${win##*::}
      win=${win%::*}
      if [[ -z "${new_session}" ]]; then
        # Pass empty TMUX env var to keep tmux happy when creating
        # from within tmux
        new_session="\
            TMUX= tmux new -d -s ${project_name} -n ${win} '${cmd}' \
            &> /dev/null"
      else
        # Create other windows listed in PROJECT_WINDOWS env var
        new_session="\
            ${new_session} && tmux new-window -t ${project_name} -d \
            -n ${win} '${cmd}' &> /dev/null"
      fi
    done

    # Commands to attach to default project session
    local attach_session="tmux attach -t ${session} &> /dev/null"
    if [[ -n "${instance_suffix}" ]]; then
      # Instance given so session group used. If fail to attach to a session
      # group then create a new session group based on project session.
      #
      # NOTE: To handle case where the project session may not have been created
      # yet (e.g. 'project attach foo 2' was used before 'project attach foo')
      # we will always try to create a new project session  before attempting to
      # create a session group. If the project session already exists we just
      # throw out the error and move on to session group creation.
      local attach_session="${attach_session} || \
          { { ${new_session}; }; \
          TMUX= tmux new -t ${project_name} -s ${session} &> /dev/null; }"
    fi

    # Commands to attach/switch to new session
    local attach_new_session="tmux attach -t ${project_name} &> /dev/null"
    if __projux_is_project_local && [[ -n "${cur_session}" ]]; then
      attach_new_session="tmux switch -t ${project_name} &> /dev/null"
    fi

    # Attach to session or create a new session
    local cmd="${attach_session} || \
        { ${new_session} && ${attach_new_session}; }"
  fi

  if __projux_is_project_local; then
    eval "$cmd"
  else
    ssh -Y -t ${PROJECT_HOST-${DEFAULT_PROJECT_HOST}} "${cmd}"
  fi
}

################################################################################
# Backs up project files.
#
# Files are backed up to PROJECT_BACKUP_DIR/<timestamp>
#
# Args:
#   $1: Project name
################################################################################
function __projux_project_backup() {
  local project_name="${1}"

  local project_host=$(__projux_project_var "${project_name}" "PROJECT_HOST")
  if [[ -z "${project_host}" ]]; then
    project_host="${DEFAULT_PROJECT_HOST}"
  fi

  local backup_dir=$(\
      __projux_project_var "${project_name}" "PROJECT_BACKUP_DIR")
  if [[ -z "${backup_dir}" ]]; then
    backup_dir="${DEFAULT_PROJECT_BACKUP_DIR}/${project_name}"
  fi

  # This assumes the git repo is rooted at the PROJECT_DIR
  local project_dir=$(\
      __projux_project_var "${project_name}" "PROJECT_DIR")
  if [[ -z "${project_dir}" ]]; then
    echo "$(tput setaf 1)PROJECT_DIR must be configured$(tput sgr0)"
    return 1
  fi

  local pushd_cmd="pushd ${project_dir} &> /dev/null"
  local git_cmd='$(git ls-files -m -o --directory'
  git_cmd="$git_cmd --no-empty-directory --exclude-standard 2> /dev/null)"
  local files_cmd="files=${git_cmd}"
  local time_cmd='cur_time=$(date +"%FT%T")'
  local mkdir_cmd="mkdir -p ${backup_dir}/"'${cur_time}'
  local cp_cmd='for f in ${files}; do'
  cp_cmd="${cp_cmd} mkdir -p ${backup_dir}/"'${cur_time}/${f%/*}'
  cp_cmd="${cp_cmd}; "'f=${f%/}'
  cp_cmd="${cp_cmd}; cp -r ${project_dir}/"'${f} '
  cp_cmd="${cp_cmd}""${backup_dir}/"'${cur_time}/${f%/*}; done'
  local cmd="$pushd_cmd && {$files_cmd && $time_cmd && $mkdir_cmd && $cp_cmd;}"
  local cmd="${cmd}; popd &> /dev/null"

  if __projux_is_project_local; then
    eval "$cmd"
  else
    PROJECT_HOST=${project_host} __projux_ssh_send $cmd 2> /dev/null
  fi
}

################################################################################
# Syncs local and remote project files (internal use).
#
# Args:
#   $1: Project name
################################################################################
function __projux_project_sync() {
  local project_name="${1}"

  local project_host=$(__projux_project_var "${project_name}" "PROJECT_HOST")
  if [[ __projux_is_project_local || -z "${project_host}" ]]; then
    project_host="${DEFAULT_PROJECT_HOST}"
  fi

  local project_sync_dests=$(\
      __projux_project_var "${project_name}" "PROJECT_SYNC_DESTS")
  if [[ -z "${project_sync_dests}" ]]; then
    project_sync_dests="${DEFAULT_PROJECT_SYNC_DESTS}"
  fi

  local project_sync_list=$(\
      __projux_project_var "${project_name}" "PROJECT_SYNC_LIST")
  if [[ -z "${project_sync_list}" ]]; then
    project_sync_list="${DEFAULT_PROJECT_SYNC_LIST}"
  fi

  local first_dir=${project_sync_dests%%,*}
  OLDIFS=$IFS
  IFS=$','
  for dir in ${project_sync_dests}; do
    rsync -ravz --files-from=${project_sync_list} \
      --exclude="tags" --exclude="tags-ja" ~ -e ssh ${project_host}:${dir}
  done
  IFS=$OLDIFS

  return 0
}


################################################################################
# Key/Value Helper Functions
################################################################################

################################################################################
# Returns expression that can be evaluated to create a key::value list array.
#
# This is needed because values may have spaces in them. For example:
#
#   # Equivalent to: local kv_list=("foo:foo -test:it" "bar::bar -f")
#   eval $(__projux_key_value_list "kv_list" "foo::foo -test:it bar::bar -f")
#
# Args:
#   $1: Var name
#   $*: Map (e.g. <key>::<value> <key>::<value> ...)
#
# Returns:
#   ""<key>::<value>" "<key>::<value>" ..."
################################################################################
function __projux_key_value_list() {
  local var=${1}
  shift
  local arr=()
  local cur=""
  local entry
  for entry in "$@"; do
    entry=$(echo ${entry}) # trim whitespace
    if [[ "${entry}" == *::* ]]; then
      if [[ -n "${cur}" ]]; then arr+=("\"${cur}\""); fi
      cur=${entry}
    else
      cur="${cur} ${entry}"
    fi
  done
  if [[ -n "${cur}" ]]; then arr+=("\"${cur}\""); fi
  echo "local ${var}=(${arr[@]})"
}

################################################################################
# Helper function to choose value from a list of key/values and flags.
#
# Example (cmds=test1::test1 --foo=a, --bar=b test2::test2 --bat=c)
#   # test1 --foo=a,d,e ==bar=b
#   __projux_key_value ${cmds} test1 --foo=+d,+e
#
# Args:
#   $1: List of keys/values (<key>::<value> <key>::<value> ...).
#   $2: Name of an embedded value within ${1}
#   $*: Modifications to default flags
#
# Returns:
#   Full form of embedded command after flag changes.
################################################################################
function __projux_key_value() {
  local values="${1}"
  shift
  local value="${1}"
  if [[ $# -gt 0 ]]; then
    # Search for key (e.g. foo in "foo::foo --flags bar::bar --flags")
    if [[ "${values}" =~ "${value}::" ]]; then
      # Strip everything up to including foo::
      values=${values#*${value}::}
      if [[ "${values}" =~ "::" ]]; then
        # Strip from first remaining :: to end
        values=${values%%::*}
        # Strip last word (e.g. bar from bar:: will be remaining)
        values=${values% [^ ]*}
      fi
      shift
    fi
  elif [[ "${values}" =~ "::" ]]; then
    # Multiple entries, choose first (same as above algorithm, only no label)
    values=${values#*::}
    if [[ "${values}" =~ "::" ]]; then
      values=${values%%::*}
      values=${values% [^ ]*}
    fi
  fi

  # Check if additional args passed requiring flag addition/replacement
  if [[ $# -gt 0 ]]; then
    local flag=""
    local old_value=""
    local new_value=""
    local flag_value=""
    local flag_prefix=""  # prefix to add to flag (e.g. --, --no, etc)
    local prefix=""       # prefix before flag
    local suffix=""       # suffix after flag
    local tmp=""
    local OLDIFS=$IFS
    IFS=$' '
    for arg in $*; do
      new_value=""
      flag_prefix=""
      # find flag name (if used)
      if [[ "${arg}" =~ "=" ]]; then        # --foo=bar
        flag=${arg%%=*}   # --foo or -foo
        if [[ "${flag}" == --* ]]; then   # --foo
          flag=${flag:2}  # foo
          flag_prefix="--"
        else                              # -foo
          flag=${flag:1}  # foo
          flag_prefix="-"
        fi
        new_value=${arg#*=}      # bar
      elif [[ "${arg}" == --no* ]]; then  # --nofoo
        flag=${arg:4}     # foo
        flag_prefix="--no"
      elif [[ "${arg}" == -no* ]]; then   # -nofoo
        flag=${arg:3}     # foo
        flag_prefix="-no"
      elif [[ "${arg}" == --* ]]; then    # --foo
        flag=${arg:2}     # foo
        flag_prefix="--"
      elif [[ "${arg}" == -* ]]; then     # -foo
        flag=${arg:1}     # foo
        flag_prefix="-"
      else                                # foo (e.g. not a flag)
        flag=${arg}       # foo
        flag_prefix=""
      fi

      # find flag in current value and splice around it
      #    values   : 'mycmd --f1 --f2=a --f3=b'
      #    flag     : 'f2'
      #
      #    prefix   : 'mycmd --f1 '
      #    old_value : 'a'
      #    suffix   : ' --f3=b'
      old_value=""
      if [[ "${values}" =~ "--no${flag}" ]]; then
        suffix=${values#*--no${flag}}   # Strip up to including --noflag
        prefix=${values:0:${#values}-${#suffix}-4-${#flag}}  # -4 for --no
      elif [[ "${values}" =~ "-no${flag}" ]]; then
        suffix=${values#*-no${flag}}    # Strip up to including -noflag
        prefix=${values:0:${#values}-${#suffix}-3-${#flag}}  # -3 for -no
      elif [[ "${values}" =~ "--${flag}=" ]]; then
        suffix=${values#*--${flag}=}    # Strip up to including --flag=
        prefix=${values:0:${#values}-${#suffix}-3-${#flag}}  # -3 for --,=
        old_value=${suffix%% *}   # Strip up to first space
        suffix=${suffix:${#old_value}}
      elif [[ "${values}" =~ "-${flag}=" ]]; then
        suffix=${values#*-${flag}=}     # Strip up to including -flag=
        prefix=${values:0:${#values}-${#suffix}-2-${#flag}}  # -2 for -,=
        old_value=${suffix%% *}   # Strip up to first space
        suffix=${suffix:${#old_value}}
      elif [[ "${values}" =~ "--${flag}" ]]; then
        suffix=${values#*--${flag}}     # Strip up to including --flag
        prefix=${values:0:${#values}-${#suffix}-2-${#flag}}  # -2 for --
      elif [[ "${values}" =~ "-${flag}" ]]; then
        suffix=${values#*-${flag}}      # Strip up to including -flag
        prefix=${values:0:${#values}-${#suffix}-1-${#flag}}  # -1 for -
      else
        prefix=${values}
        # new flag or new arg, add space before prefix
        flag_prefix=" ${flag_prefix}"
      fi

      IFS=$','
      local v
      for v in $new_value; do
        if [[ "$v" == +* ]]; then
          v=${v:1}
          # --foo=+bar (or -foo=+bar) means add bar to existing foo flag values
          if [[ ! "${old_value}" =~ $v ]]; then
            old_value="${old_value},${v}"
            new_value=${old_value}
          fi
        elif [[ "$v" == -* ]]; then
          v=${v:1}
          # --foo=-bar (or -foo=-bar) means remove bar from existing flag values
          if [[ "${old_value}" =~ ,$v ]]; then
            tmp=${old_value#*,$v}
            tmp=${old_value:0:${#old_value}-${#tmp}-1-${#v}}$tmp
            old_value=$tmp
            new_value=$tmp
          elif [[ "${old_value}" =~ $v, ]]; then
            tmp=${old_value#*$v,}
            tmp=${old_value:0:${#old_value}-${#tmp}-1-${#v}}$tmp
            old_value=$tmp
            new_value=$tmp
          elif [[ "${old_value}" == "${v}" ]]; then  # removed flag altogether
            flag_prefix=""
            flag=""
            new_value=""
          fi
        else
          # --foo=bar (or -foo=bar) means replace existing foo flag with bar
          old_value=$new_value
        fi
      done
      IFS=$' '

      if [[ -n "${new_value}" ]]; then
        values="${prefix}${flag_prefix}${flag}=${new_value}${suffix}"
      else
        values="${prefix}${flag_prefix}${flag}${new_value}${suffix}"
      fi
    done
    IFS=$OLDIFS
  fi
  echo "${values}"
}

################################################################################
# Extracts value for the a given file extension.
#
# Args:
#   $1: Extension
#   $2: <file_ext>:...:<file_ext>::<value> ...
#
# Returns:
#   Value or empty string.
################################################################################
function __projux_value_for_ext() {
  OLDIFS=$IFS
  IFS=$' '
  local entry
  eval "$(__projux_key_value_list kv_list ${2})"
  for entry in "${kv_list[@]}"; do
    if [[ "${entry%%::*}:" =~ "${1}:" ]]; then
      echo "${entry#*::}"
      IFS=$OLDIFS
      return 0
    fi
  done
  IFS=$OLDIFS
  return 1
}

################################################################################
# Help
################################################################################

function __projux_print_builtins() {
  echo "project                               - display current project"
  echo "project ls                            - list projects"
  echo "project <name>                        - if attached switch, else load"
  echo "project attach/detach/kill [<name>]   - attach/detach/kill tmux"
  echo "project sessions                      - list attached sessions"
  echo "project settings [<name>]             - show project settings"
  echo "project backup [<name>]               - backup files not in git repo"
  echo "project clear                         - clears project settings"
  echo "project sync [<name>]                 - sync local files to project"
  echo "project companion [<name>]            - show session group companion"
  echo "win [new] [<name>]                    - display/create tmux win"
  echo "pane [new|split|vsplit] [<name>]      - display/create tmux pane"
  echo "pssh                                  - ssh to project server"
  echo "psftp                                 - sftp to project server"
  echo "pvim                                  - run project server mode vim"
}
