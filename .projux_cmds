###############################################################################
# Copyright 2012-2013 Mike Dreves
#
# All rights reserved. This program and the accompanying materials
# are made available under the terms of the Eclipse Public License v1.0
# which accompanies this distribution, and is available at:
#
#  http://opensource.org/licenses/eclipse-1.0.php
#
# By using this software in any fashion, you are agreeing to be bound
# by the terms of this license. You must not remove this notice, or any
# other, from this software. Unless required by applicable law or agreed
# to in writing, software distributed under the License is distributed
# on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
# either express or implied.
###############################################################################

################################################################################
# Commands Based on File Type
################################################################################

################################################################################
# Runs format.
#
# REQUIREMENTS: project env vars are properly set (via 'project <name>')
#
# By default, this function relies on the existance of a PROJECT_FORMAT_CMDS
# (or DEFAULT_PROJECT_FORMAT_CMDS) environment varible that specifies which
# format commands to run on different file types. If the default implementation
# is not enough, then a custom function implementation can be provided using
# PROJECT_FORMAT_FN.
#
# This function supports the ability to pass either stdin to be formatted or a
# list of files. When no args are passed all files within the PROJECT_SRC_DIR
# and PROJECT_TEST_DIR that match the PROJECT_INCLUDE_FILTER and
# PROJECT_EXLUCDE_FILTER settings are used.
#
# When stdin is used, the environment varible FILE_TYPE must be set to
# provide a hint about which format function to use.
#
# Examples:
#   cat foo | FILE_TYPE=cc format  # format stdin
#   format foo.cc                  # format specific file
#   format                         # format recursively from current dir
#   format ...                     # as above
#   format :project                # format project src/test targets
#   format -p xxx ...              # format recursively in project xxx
#   VERBOSE=0 format
#   DRY_RUN=true format
#
# Args:
#   $*: Targets.
################################################################################
function format() {
  local project_name="${PROJECT_NAME}"
  if [[ "${1}" == "-p" ]]; then
    shift
    project_name="${1}"
    shift
  fi

  if [[ "${project_name%%:*}" != "${PROJECT_NAME}" || ! is_dev_local ]]; then
    __projux_tmux_send "$(__default_project_win ${project_name})" "format" $*
    return $?
  fi

  custom_fn=${PROJECT_FORMAT_FN-${DEFAULT_PROJECT_FORMAT_FN}}
  if [[ -n "${custom_fn}" ]]; then
    local cmd="${custom_fn} $@"
    eval "$cmd"
  else
    if [[ $# -eq 0 ]]; then
      local targets="..."
    elif [[ "${1}" == ":project" ]]; then
      # Use src/test directories as targets
      local targets=$(__projux_expand_pkgs 3)
    else
      local targets="$@"
    fi

    if [[ -z "${OUT_DIR}" ]]; then
      if ! __projux_create_target_subdir "format"; then return 1; fi
      local out_dir=${PROJECT_TARGET_DIR}/format
    else
      local out_dir=${OUT_DIR}
    fi
    local exec_cmds=${PROJECT_FORMAT_CMDS-${DEFAULT_PROJECT_FORMAT_CMDS}}
    HEADING="FORMATTING" OUT_DIR=${out_dir} EXEC_CMDS="${exec_cmds}" \
        __projux_exec ${targets}
  fi
  return $?
}

################################################################################
# Runs lint.
#
# REQUIREMENTS: project env vars are properly set (via 'project <name>')
#
# By default, this function relies on the existance of a PROJECT_LINT_CMDS
# (or DEFAULT_PROJECT_LINT_CMDS) environment varible that specifies which
# lint commands to run on different file types. If the default implementation
# is not enough, then a custom function implementation can be provided using
# PROJECT_LINT_FN.
#
# This function supports the ability to pass either stdin to be linted or a
# list of files. When no args are passed all files within the PROJECT_SRC_DIR
# and PROJECT_TEST_DIR that match the PROJECT_INCLUDE_FILTER and
# PROJECT_EXLUCDE_FILTER settings are used.
#
# The environment variable OUT_DIR can be set to the dir to use to store
# the last_run output. By default ${PROJECT_TARGET_DIR}/lint is used.
#
# When stdin is used, the environment varible FILE_TYPE must be set to
# provide a hint about which lint function to use.
#
# Examples:
#   cat foo | FILE_TYPE=cc lint    # lint stdin
#   lint foo.cc                    # lint specific file
#   lint                           # recursively lint current dir
#   lint ...                       # as above
#   lint :project                  # lint project src/test targets
#   lint -p xxx ...                # lint recursively in project xxx
#   VERBOSE=0 lint
#   DRY_RUN=true lint
#
# Args:
#   $*: Targets.
################################################################################
function lint() {
  local project_name="${PROJECT_NAME}"
  if [[ "${1}" == "-p" ]]; then
    shift
    project_name="${1}"
    shift
  fi

  if [[ "${project_name%%:*}" != "${PROJECT_NAME}" || ! is_dev_local ]]; then
    __projux_tmux_send "$(__default_project_win ${project_name})" "lint" $*
    return $?
  fi

  custom_fn=${PROJECT_LINT_FN-${DEFAULT_PROJECT_LINT_FN}}
  if [[ -n "${custom_fn}" ]]; then
    local cmd="${custom_fn} $@"
    eval "$cmd"
  else
    if [[ $# -eq 0 ]]; then
      local targets="..."
    elif [[ "${1}" == ":project" ]]; then
      # Use src/test directories as targets
      local targets=$(__projux_expand_pkgs 3)
    else
      local targets="$@"
    fi

    if [[ -z "${OUT_DIR}" ]]; then
      if ! __projux_create_target_subdir "lint"; then return 1; fi
      local out_dir=${PROJECT_TARGET_DIR}/lint
    else
      local out_dir=${OUT_DIR}
    fi
    local exec_cmds=${PROJECT_LINT_CMDS-${DEFAULT_PROJECT_LINT_CMDS}}
    HEADING="LINTING" OUT_DIR="${out_dir}" EXEC_CMDS="${exec_cmds}" \
        __projux_exec ${targets}
  fi
  return $?
}

################################################################################
# Runs build.
#
# REQUIREMENTS: project env vars are properly set (via 'project <name>')
#
# By default, this function relies on the existance of a PROJECT_BUILD_CMDS
# (or DEFAULT_PROJECT_BUILD_CMDS) environment varible that specifies which
# build commands to run on different file types. If the default implementation
# is not enough, then a custom function implementation can be provided using
# PROJECT_BUILD_FN.
#
# This function supports the ability to pass either stdin to be built or a
# list of files. When no args are passed all files within the PROJECT_SRC_DIR
# and PROJECT_TEST_DIR that match the PROJECT_INCLUDE_FILTER and
# PROJECT_EXCLUDE_FILTER settings are used.
#
# The environment variable OUT_DIR can be set to the dir to use to store
# the last_run output. By default ${PROJECT_TARGET_DIR}/build is used.
#
# When stdin is used, the environment varible FILE_TYPE must be set to
# provide a hint about which build function to use.
#
# Examples:
#   cat foo | FILE_TYPE=scala build    # build stdin
#   build foo.scala                    # build specific file
#   build ...                          # build recursively from current dir
#   build                              # as above
#   build :project                     # build project src/test targets
#   build -p xxx ...                   # build recursively in project xxx
#   VERBOSE=0 build
#   DRY_RUN=true build
#
# Args:
#   $*: Targets.
################################################################################
function build() {
  local project_name="${PROJECT_NAME}"
  if [[ "${1}" == "-p" ]]; then
    shift
    project_name="${1}"
    shift
  fi

  if [[ "${project_name%%:*}" != "${PROJECT_NAME}" || ! is_dev_local ]]; then
    __projux_tmux_send "$(__default_project_win ${project_name})" "build" $*
    return $?
  fi

  custom_fn=${PROJECT_BUILD_FN-${DEFAULT_PROJECT_BUILD_FN}}
  if [[ -n "${custom_fn}" ]]; then
    local cmd="${custom_fn} $@"
    eval "$cmd"
  else
    if [[ $# -eq 0 ]]; then
      local targets="..."
    elif [[ "${1}" == ":project" ]]; then
      # Use src/test directories as targets
      local targets=$(__projux_expand_pkgs 3)
    else
      local targets="$@"
    fi

    if [[ -z "${OUT_DIR}" ]]; then
      if ! __projux_create_target_subdir "build"; then return 1; fi
      local out_dir=${PROJECT_TARGET_DIR}/build
    else
      local out_dir=${OUT_DIR}
    fi
    local exec_cmds=${PROJECT_BUILD_CMDS-${DEFAULT_PROJECT_BUILD_CMDS}}
    HEADING="BUILDING" OUT_DIR="${out_dir}" EXEC_CMDS="${exec_cmds}" \
        __projux_exec ${targets}
  fi
  return $?
}

################################################################################
# Runs test.
#
# REQUIREMENTS: project env vars are properly set (via 'project <name>')
#
# By default, this function relies on the existance of a PROJECT_TEST_CMDS
# (or DEFAULT_PROJECT_TEST_CMDS) environment varible that specifies which
# test commands to run on different file types. If the default implementation
# is not enough, then a custom function implementation can be provided using
# PROJECT_TEST_FN.
#
# This function takes a list of targets. When no args are passed all files
# within the PROJECT_SRC_DIR and PROJECT_TEST_DIR that match the
# PROJECT_TEST_TARGETS settings. If PROJECT_TEST_TARGETS is not set, then
# PROJECT_INCLUDE_FILTER and PROJECT_EXCLUDE_FILTER settings are used. In
# either case, the entries are futher filtered by PROJECT_TEST_SUFFIXES (when
# set) to only include files matching the suffix. Filename extensions are
# removed by default (e.g. foo_test.cc will be targeted as foo_test).
#
# The environment variable OUT_DIR can be set to the dir to use to store
# the last_run output. By default ${PROJECT_TARGET_DIR}/test is used.
#
# Examples:
#   test foo_class_test            # test foo_class_test
#   test foo_class_test.cc         # test foo_class_test (auto removes .cc)
#   test                           # all test targets recursivey from cur dir
#   test ...                       # as above
#   test :project                  # test matching targets in project test dir
#   test -p xxx foo_class_test     # test foo_class_test in project xxx
#   VERBOSE=0 test foo_class_test
#   DRY_RUN=true test foo_class_test
#
# Args:
#   $*: Targets.
################################################################################
function test() {
  local project_name="${PROJECT_NAME}"
  if [[ "${1}" == "-p" ]]; then
    shift
    project_name="${1}"
    shift
  fi

  if [[ "${project_name%%:*}" != "${PROJECT_NAME}" || ! is_dev_local ]]; then
    __projux_tmux_send "$(__default_project_win ${project_name})" "test" $*
    return $?
  fi

  custom_fn=${PROJECT_TEST_FN-${DEFAULT_PROJECT_TEST_FN}}
  if [[ -n "${custom_fn}" ]]; then
    local cmd="${custom_fn} $@"
    eval "$cmd"
  else
    if [[ $# -eq 0 ]]; then
      local targets="..."
    elif [[ "${1}" == ":project" ]]; then
      # Use test directories as targets
      local targets=$(__projux_expand_pkgs 2)
    else
      local targets="$@"
    fi

    if [[ -z "${OUT_DIR}" ]]; then
      if ! __projux_create_target_subdir "test"; then return 1; fi
      local out_dir=${PROJECT_TARGET_DIR}/test
    else
      local out_dir=${OUT_DIR}
    fi

    local suffixes_filter="\
        ${PROJECT_TEST_SUFFIXES-${DEFAULT_PROJECT_TEST_SUFFIXES}}"
    local exec_cmds=${PROJECT_TEST_CMDS-${DEFAULT_PROJECT_TEST_CMDS}}
    if [[ -n "${PROJECT_TEST_TARGETS}" ]]; then
      HEADING="TESTING" OUT_DIR="${out_dir}" \
          PROJECT_INCLUDE_FILTER=${PROJECT_TEST_TARGETS} \
          SUFFIXES_FILTER=${suffixes_filter} REMOVE_EXTENSIONS=1 \
          EXEC_CMDS="${exec_cmds}" __projux_exec ${targets}
    else
      HEADING="TESTING" OUT_DIR="${out_dir}" EXEC_CMDS="${exec_cmds}" \
          SUFFIXES_FILTER=${suffixes_filter} REMOVE_EXTENSIONS=1 \
          __projux_exec ${targets}
    fi
  fi
  return $?
}

################################################################################
# Runs coverage.
#
# REQUIREMENTS: project env vars are properly set (via 'project <name>')
#
# By default, this function relies on the existance of a PROJECT_TEST_CMDS
# (or DEFAULT_PROJECT_TEST_CMDS) environment varible that specifies which
# coverage commands to run on different file types. If the default
# implementation is not enough, then a custom function implementation can be
# provided using PROJECT_COVERAGE_FN.
#
# This function takes a list of targets. When no args are passed all files
# within the PROJECT_SRC_DIR and PROJECT_TEST_DIR that match the
# PROJECT_TEST_TARGETS settings. If PROJECT_TEST_TARGETS is not set, then
# PROJECT_INCLUDE_FILTER and PROJECT_EXCLUDE_FILTER settings are used. In
# either case, the entries are futher filtered by PROJECT_TEST_SUFFIXES (when
# set) to only include files matching the suffix. Filename extensions are
# removed by default (e.g. foo_test.cc will be targeted as foo_test).
#
# The environment variable OUT_DIR can be set to the dir to use to store
# the last_run output. By default ${PROJECT_TARGET_DIR}/coverage is used.
#
# Examples:
#   coverage foo_class_test        # coverage of foo_class_test
#   coverage                       # coverage of all targets recursively
#   coverage ...                   # as above
#   coverage :project              # coverage of targets in project test dir
#   coverage -p xxx foo_class_test # coverage of foo_class_test in project xxx
#   VERBOSE=0 coverage
#   DRY_RUN=true coverage
#
# Args:
#   $*: Targets.
################################################################################
function coverage() {
  local project_name="${PROJECT_NAME}"
  if [[ "${1}" == "-p" ]]; then
    shift
    project_name="${1}"
    shift
  fi

  if [[ "${project_name%%:*}" != "${PROJECT_NAME}" || ! is_dev_local ]]; then
    __projux_tmux_send "$(__default_project_win ${project_name})" "coverage" $*
    return $?
  fi

  custom_fn=${PROJECT_COVERAGE_FN-${DEFAULT_PROJECT_COVERAGE_FN}}
  if [[ -n "${custom_fn}" ]]; then
    local cmd="${custom_fn} $@"
    eval "$cmd"
  else
    if [[ $# -eq 0 ]]; then
      local targets="..."
    elif [[ "${1}" == ":project" ]]; then
      # Use test directories as targets
      local targets=$(__projux_expand_pkgs 2)
    else
      local targets="$@"
    fi

    if [[ -z "${OUT_DIR}" ]]; then
      if ! __projux_create_target_subdir "coverage"; then return 1; fi
      local out_dir=${PROJECT_TARGET_DIR}/coverage
    else
      local out_dir=${OUT_DIR}
    fi

    local suffixes_filter="\
        ${PROJECT_TEST_SUFFIXES-${DEFAULT_PROJECT_TEST_SUFFIXES}}"
    local exec_cmds=${PROJECT_COVERAGE_CMDS-${DEFAULT_PROJECT_COVERAGE_CMDS}}
    if [[ -n "${PROJECT_TEST_TARGETS}" ]]; then
      HEADING="COVERAGE" OUT_DIR="${out_dir}" \
         PROJECT_INCLUDE_FILTER=${PROJECT_TEST_TARGETS} \
         SUFFIXES_FILTER=${suffixes_filter} REMOVE_EXTENSIONS=1 \
         EXEC_CMDS="${exec_cmds}" __projux_exec ${targets}
    else
      HEADING="COVERAGE" OUT_DIR="${out_dir}" \
         SUFFIXES_FILTER=${suffixes_filter} REMOVE_EXTENSIONS=1 \
         EXEC_CMDS="${exec_cmds}" __projux_exec ${targets}
    fi
  fi
  return $?
}


################################################################################
# Selectable Commands
################################################################################

################################################################################
# Runs program.
#
# REQUIREMENTS: project env vars are properly set (via 'project <name>')
#
# This function relies on the existance of a PROJECT_RUN_CMDS variable (or
# DEFAULT_PROJECT_RUN_CMDS).
#
# Examples:
#   run                        # run first entry in ${PROJECT_RUN_CMDS}
#   run prog                   # run 'prog' entry in ${PROJECT_RUN_CMDS}
#   run prog --foo=+bar,+baz   # add 'bar' and 'baz' to --foo flag before run
#   run prog --foo=-bar        # remove 'bar' from --foo flag before run
#   run prog --foo=bar         # replace default --foo flag value with bar
#   run -shared prog
#   VERBOSE=0 run prog
#   DRY_RUN=true run prog
#
# Args:
#   target (optional): Target (prog)
#   flags (optional): -shared (run prog in ~/Public/)
################################################################################
function run() {
  local project_name="${PROJECT_NAME}"
  if [[ "${1}" == "-p" ]]; then
    shift
    project_name="${1}"
    shift
  fi

  if [[ "${project_name%%:*}" != "${PROJECT_NAME}" || ! is_dev_local ]]; then
    __projux_tmux_send \
        "$(__projux_default_project_win ${project_name})" "run" $*
    return $?
  fi

  local shared=false
  if [[ "${1}" == *"-shared" ]]; then
    shared=true
    shift
  fi

  local run_cmd=$(__projux_get_run_cmd ${project_name%%:*} $*)

  local cmd="${PROJECT_BIN_DIR}/${run_cmd}"
  if $shared; then
    local share_dir="\
        ${PROJECT_SHARE_DIR-${DEFAULT_PROJECT_SHARE_DIR}/${project_name%%:*}}"
    cmd="${share_dir}/${run_cmd}"
  fi

  if [[ -z "${VERBOSE}" || ${VERBOSE} -ne 0 ]]; then
    __projux_print_cmd "RUNNING" "${cmd}"
  fi

  if [[ ${DRY_RUN-false} -eq 0 ]]; then
    $cmd
  fi
}

################################################################################
# Cleans code base.
#
# REQUIREMENTS: project env vars are properly set (via 'project <name>')
#
# This function relies on the existance of a PROJECT_CLEAN_CMDS variable (or
# DEFAULT_PROJECT_CLEAN_CMDS).
#
# Examples:
#   clean
#   clean -p xxx                   # cleans project xxx
#   VERBOSE=0 clean
#   DRY_RUN=true clean
################################################################################
function clean() {
  local project_name="${PROJECT_NAME}"
  if [[ "${1}" == "-p" ]]; then
    shift
    project_name="${1}"
    shift
  fi

  if [[ "${project_name%%:*}" != "${PROJECT_NAME}" || ! is_dev_local ]]; then
    __projux_tmux_send "$(__default_project_win ${project_name})" "clean" $*
    return $?
  fi

  local cmds=${PROJECT_CLEAN_CMDS-${DEFAULT_PROJECT_CLEAN_CMDS}}
  local cmd=$(__projux_key_value "${cmds}" "$@")

  if [[ -z "${cmd}" ]]; then
    local target_dir=${PROJECT_TARGET_DIR-${DEFAULT_PROJECT_TARGET_DIR}}
    if [[ -z "${target_dir}" ]]; then
      echo "$(tput setaf 1)ERROR: PROJECT_TARGET_DIR not set$(tput sgr0)"
      return 1
    else
      cmd="rm -f ${target_dir}"
    fi
  fi

  if [[ -z "${VERBOSE}" || ${VERBOSE} -ne 0 ]]; then
    __projux_print_cmd "CLEANING" "${cmd}"
  fi

  if ! ${DRY_RUN-false}; then
    $cmd
  fi
  return $?
}

################################################################################
# Runs package command for project.
#
# REQUIREMENTS: project env vars are properly set (via 'project <name>')
#
# This function relies on the existance of a PROJECT_PACKAGE_CMDS variable (or
# DEFAULT_PROJECT_PACKAGE_CMDS).
#
# Examples:
#   package
#   package -p xxx                 # package project xxx
#   VERBOSE=0 package
#   DRY_RUN=true package
################################################################################
function package() {
  __projux_select_cmd "PROJECT_PACKAGE_CMDS" "PACKAGING" $*
}

################################################################################
# Runs deploy command for project.
#
# REQUIREMENTS: project env vars are properly set (via 'project <name>')
#
# This function relies on the existance of a PROJECT_DEPLOY_CMDS variable (or
# DEFAULT_PROJECT_DEPLOY_CMDS).
#
# Examples:
#   deploy
#   deploy -p xxx                  # deploy project xxx
#   VERBOSE=0 deploy
#   DRY_RUN=true deploy
################################################################################
function deploy() {
  __projux_select_cmd "PROJECT_DEPLOY_CMDS" "DEPLOYING" $*
}

################################################################################
# Runs gendocs command for project.
#
# REQUIREMENTS: project env vars are properly set (via 'project <name>')
#
# This function relies on the existance of a PROJECT_GENDOCS_CMDS variable (or
# DEFAULT_PROJECT_GENDOCS_CMDS).
#
# Examples:
#   gendocs
#   gendocs -p xxx                 # gendocs project xxx
#   VERBOSE=0 gendocs
#   DRY_RUN=true gendocs
################################################################################
function gendocs() {
  __projux_select_cmd "PROJECT_GENDOCS_CMDS" "GENERATING DOCS" $*
}

################################################################################
# Searches code base.
#
# REQUIREMENTS: project env vars are properly set (via 'project <name>')
#
# This function relies on the existance of a PROJECT_SEARCH_CMDS variable (or
# DEFAULT_PROJECT_SEARCH_CMDS).
#
# Examples:
#   search foo
#   search -p xxx foo         # searches foo in project xxx
#   VERBOSE=0 search foo
#   DRY_RUN=true search foo
#
# Args:
#   keywords: List of keywords to search for
################################################################################
function search() {
  __projux_select_cmd "PROJECT_SEARCH_CMDS" "SEARCHING" $*
}


################################################################################
# Misc Commands
################################################################################

################################################################################
# Runs sanity checks (lint, test, etc) - usually used before submitting code.
#
# REQUIREMENTS: project env vars are properly set (via 'project <name>')
#
# Examples:
#   santity
#   VERBOSE=0 sanity     # verbose
#   DRY_RUN=true sanity  # dry-run
#
# This function relies on the existance of a function pointed to by the
# PROJECT_SANITY_FN environment variable (set in ~/.projects) or
# DEFAULT_PROJECT_SANITY_FN (set in ~/.bashrc).
################################################################################
function sanity() {
  local project_name="${PROJECT_NAME}"
  if [[ "${1}" == "-p" ]]; then
    shift
    project_name="${1}"
    shift
  fi

  if [[ "${project_name%%:*}" != "${PROJECT_NAME}" || ! is_dev_local ]]; then
    __projux_tmux_send \
        "$(__projux_default_project_win ${project_name})" "sanity" $*
    return $?
  fi

  custom_fn=${PROJECT_SANITY_FN-${DEFAULT_PROJECT_SANITY_FN}}
  if [[ -n "${custom_fn}" ]]; then
    local cmd="${custom_fn} $@"
    eval "$cmd"
  else
    if [[ ${DRY_RUN-false} -eq 0 ]]; then
      return 0
    fi

    format ":project"
    if [[ $? -ne 0 ]]; then
      echo "$(tput setaf 1)FORMAT failed$(tput sgr0)"
      return 1
    fi

    lint ":project"
    if [[ $? -ne 0 ]]; then
      echo "$(tput setaf 1)LINT failed$(tput sgr0)"
      geterrors ":lint"
      return 1
    fi

    build ":project"
    if [[ $? -ne 0 ]]; then
      echo "$(tput setaf 1)BUILD failed$(tput sgr0)"
      geterrors ":build"
      return 1
    fi

    test ":project"
    if [[ $? -ne 0 ]]; then
      echo "$(tput setaf 1)TEST failed$(tput sgr0)"
      geterrors ":test"
      return 1
    fi

    coverage ":project"
    if [[ $? -ne 0 ]]; then
      echo "$(tput setaf 1)COVERAGE failed$(tput sgr0)"
      geterrors ":coverage"
      return 1
    fi

    # Print URLs
    echo ""
    local build=$(geturl ":build")
    if [[ -n "${build}" ]]; then
      echo "BUILD  : ${build}"
    fi
    local test=$(geturl ":test")
    if [[ -n "${test}" ]]; then
      echo "TEST     : ${test}"
    fi
    local coverage=$(geturl ":coverage")
    if [[ -n "${coverage}" ]]; then
      echo "COVERAGE : ${coverage}"
    fi
  fi
  return $?
}

################################################################################
# Copies named prog file to $PROJECT_SHARE_DIR (on current host) for sharing.
#
# REQUIREMENTS: project env vars are properly set (via 'project <name>')
#
# Example:
#   share prog
#   share -p xxx prog  # share program for project xxx
#   VERBOSE=1 share prog
#   DRY_RUN=true share prog
#
# Args:
#   target: Target file to share.
################################################################################
function share() {
  local project_name="${PROJECT_NAME}"
  if [[ "${1}" == "-p" ]]; then
    shift
    project_name="${1}"
    shift
  fi

  if [[ "${project_name%%:*}" != "${PROJECT_NAME}" || ! is_dev_local ]]; then
    __projux_tmux_send \
        "$(__projux_default_project_win ${project_name})" "share" $*
    return $?
  fi

  local prog="${1}"
  if [[ -z "${1}" ]]; then
    prog="${project_name%%:*}"
  fi

  local bin_dir=$(__projux_project_var "${project_name%%:*}" "PROJECT_BIN_DIR")
  local dst="\
      ${PROJECT_SHARE_DIR-${DEFAULT_PROJECT_SHARE_DIR}/${project_name%%:*}}"
  local cmd="cp -f ${bin_dir}/${prog} ${dst}/${prog}"

  if [[ -z "${VERBOSE}" || ${VERBOSE} -ne 0 ]]; then
    __projux_print_cmd "SHARING" "${cmd}"
  fi

  if [[ ${DRY_RUN-false} -eq 0 ]]; then
    $cmd
  fi
}

################################################################################
# Get errors from last build/lint/test/coverage (where supported).
#
# REQUIREMENTS: project env vars are properly set (via 'project <name>')
#
# This function relies on the existance of a function pointed to by the
# PROJECT_GETERRORS_FN environment variable (set in ~/.projects) or
# DEFAULT_PROJECT_GETERRORS_FN (set in ~/.bashrc).
#
# Errors should be echoed as lines of: <file>:<line>:<col>:<message>. The
# function may be called with keyword parameters such as ':build', ':lint',
# ':test', ':coverage', etc to request the errors from the last build/lint/etc
# It may also be called with a list of targets to get all the errors related to
# the target.
#
# Examples:
#   geterrors :lint           # Get errors from last call to lint
#   geterrors :build          # Get errors from last call to build
#   geterrors :test           # Get errors from last call to test
#   geterrors :coverage       # Get errors from last call to coverage
#   geterrors foo.py          # Get current foo.py errors
#   VERBOSE=0 geterrors :build
#   DRY_RUN=true geterrors :build
#
# Args:
#   type: :build, :lint, :test, :coverage, <target>
################################################################################
function geterrors() {
  local project_name="${PROJECT_NAME}"
  if [[ "${1}" == "-p" ]]; then
    shift
    project_name="${1}"
    shift
  fi

  if [[ "${project_name%%:*}" != "${PROJECT_NAME}" || ! is_dev_local ]]; then
    __projux_tmux_send \
        "$(__projux_default_project_win ${project_name})" "geterrors" $*
    return $?
  fi

  custom_fn=${PROJECT_GETERRORS_FN-${DEFAULT_PROJECT_GETERRORS_FN}}
  if [[ -n "${custom_fn}" ]]; then
    local cmd="${custom_fn} $@"
    eval "$cmd"
  else
    if [[ -z "${target_dir}" ]]; then
      echo "$(tput setaf 1)ERROR: PROJECT_TARGET_DIR not set$(tput sgr0)"
    fi

    case "${1}" in
      ":lint")
        cat "${PROJECT_TARGET_DIR}/lint/last_run"
        ;;
      ":compile"|":build")
        cat "${PROJECT_TARGET_DIR}/build/last_run"
        ;;
      ":test")
        cat "${PROJECT_TARGET_DIR}/test/last_run"
        ;;
      ":coverage")
        cat "${PROJECT_TARGET_DIR}/coverage/last_run"
        ;;
      *)
        echo "$(tput setaf 1)ERROR: unknown value ${1}$(tput sgr0)"
        ;;
    esac
  fi
  return $?
}

################################################################################
# Gets URL for review/bug/build/lint/test/coverage (where supported).
#
# REQUIREMENTS: project env vars are properly set (via 'project <name>')
#
# Examples:
#   geturl :review               # default code review url for project
#   geturl :review xxx           # code review xxx
#   geturl :bug                  # default bug for project
#   geturl :bug xxx              # bug xxx
#   geturl :build                # last build
#   geturl :test                 # last test run
#   geturl :coverage             # last coverage run
#   VERBOSE=0 geturl :build      # verbose
#   DRY_RUN=true geturl :build   # dry-run
#
# This function relies on the existance of a function pointed to by the
# PROJECT_GETURL_FN environment variable (set in ~/.projects) or
# DEFAULT_PROJECT_GETURL_FN (set in ~/.bashrc).
#
# Args:
#   type: :review, :bug, :build, :test, :coverage, etc
#   id: ide for review/bug, etc
################################################################################
function geturl() {
  local project_name="${PROJECT_NAME}"
  if [[ "${1}" == "-p" ]]; then
    shift
    project_name="${1}"
    shift
  fi

  if [[ "${project_name%%:*}" != "${PROJECT_NAME}" || ! is_dev_local ]]; then
    __projux_tmux_send \
        "$(__projux_default_project_win ${project_name})" "geturl" $*
    return $?
  fi

  custom_fn=${PROJECT_GETURL_FN-${DEFAULT_PROJECT_GETURL_FN}}
  if [[ -n "${custom_fn}" ]]; then
    local cmd="${custom_fn} $@"
    eval "$cmd"
  else
    case "${1}" in
      ":build"|":comile")
        local file=${PROJECT_TARGET_DIR}/build/last_run
        if [[ -f "${file}" ]]; then
          echo $(sed -n 's/^.*\(http[^ ]*\|file[^ ]*\)$/\1/p' ${file} | tail -1)
        fi
        ;;
      ":test")
        local file=${PROJECT_TARGET_DIR}/test/last_run
        if [[ -f "${file}" ]]; then
          echo $(sed -n 's/^.*\(http[^ ]*\|file[^ ]*\)$/\1/p' ${file} | tail -1)
        fi
        ;;
      ":coverage")
        local file=${PROJECT_TARGET_DIR}/coverage/last_run
        if [[ -f "${file}" ]]; then
          echo $(sed -n 's/^.*\(http[^ ]*\|file[^ ]*\)$/\1/p' ${file} | tail -1)
        fi
        ;;
    esac
  fi
}

################################################################################
# Open browser to bug page.
################################################################################
function openbug() { open $(geturl ":bug ${1}"); }

################################################################################
# Open browser to code review page.
################################################################################
function openreview() { open $(geturl ":review ${1}"); }

################################################################################
# Open browser to build status page.
################################################################################
function openbuild() { open $(geturl ":build"); }

################################################################################
# Open browser to test status page.
################################################################################
function opentest() { open $(geturl ":test"); }

################################################################################
# Open browser to test coverage page.
################################################################################
function opencoverage() { open $(geturl ":coverage"); }


################################################################################
# Environment Variable Management Commands
################################################################################

################################################################################
# Gets default tests.
#
# REQUIREMENTS: project env vars are properly set (via 'project <name>')
#
# Echos PROJECT_TEST_TARGETS environment variable
#
# Example:
#   gettest
################################################################################
function gettest() {
  local project_name="${PROJECT_NAME}"
  if [[ "${1}" == "-p" ]]; then
    shift
    project_name="${1}"
    shift
  fi

  if [[ "${project_name%%:*}" != "${PROJECT_NAME}" ]]; then
    echo "$(__projux_project_var ${project_name} PROJECT_TEST_TARGETS)"
  else
    echo "$PROJECT_TEST_TARGETS"
  fi
}

################################################################################
# Sets default tests.
#
# Replaces the PROJECT_TEST_TARGETS environment variable with the specified
# tests
#
# Examples:
#   settest foo_test ../common/bar_test
#
# Args:
#   targets: Target tests.
################################################################################
function settest() {
  local project_name="${PROJECT_NAME}"
  if [[ "${1}" == "-p" ]]; then
    shift
    project_name="${1}"
    shift
  fi

  if [[ "${project_name%%:*}" != "${PROJECT_NAME}" || ! is_dev_local ]]; then
    __projux_tmux_send \
        "$(__projux_default_project_win ${project_name})" "settest" $*
    return $?
  fi

  local targets=""
  for target in $(\
      BASE_DIR=${PROJECT_DIR} __projux_normalize_targets "$@"); do
    # Strip pre-package path
    local normalized_target=${target##${PROJECT_TEST_DIR}}
    # Remove any extension
    if [[ -n "${normalized_target##*.}" ]]; then
      normalized_target=${normalized_target%.*}
    fi
    local targets="${targets} ${normalized_target}"
  done

  export PROJECT_TEST_TARGETS="${targets}"
}

################################################################################
# Updates default tests.
#
# REQUIREMENTS: project env vars are properly set (via 'project <name>')
#
# Updates the PROJECT_TEST_TARGETS environment variable to add/remove
# tests.
#
# Example:
#   updatetest +foo_test -../common/bar_test
#
# Args:
#   targets: Target tests.
################################################################################
function updatetest() {
  local project_name="${PROJECT_NAME}"
  if [[ "${1}" == "-p" ]]; then
    shift
    project_name="${1}"
    shift
  fi

  if [[ "${project_name%%:*}" != "${PROJECT_NAME}" || ! is_dev_local ]]; then
    __projux_tmux_send \
        "$(__projux_default_project_win ${project_name})" "updatetest" $*
    return $?
  fi

  # Build list of added/removed items
  local added=""
  local removed=""
  for arg in $*; do
    if [[ "${arg}" == +* ]]; then
      arg=${arg:1}
      added="${add} ${arg}"
    elif [[ "${arg}" == -* ]]; then
      arg=${arg:1}
      removed="${remove} ${arg}"
    else
      echo "$(tput setaf 3)Missing -/+ for arg ${arg}$(tput sgr0)"
    fi
  done

  # Convert removed items to full targets
  local removed_targets=""
  for target in $(\
      BASE_DIR=${PROJECT_DIR} __projux_normalize_targets ${removed}); do
    # Strip pre-package path
    local normalized_target=${target##${PROJECT_TEST_DIR}}
    # Remove any extension
    if [[ -n "${normalized_target##*.}" ]]; then
      normalized_target=${normalized_target%.*}
    fi
    local removed_targets="${removed_targets} ${normalized_target}"
  done

  # Filter removed from current targets
  local targets=""
  pushd "${PROJECT_TEST_DIR}" &> /dev/null
  for target in $(\
        BASE_DIR=${PROJECT_DIR} \
        __projux_normalize_targets ${PROJECT_TEST_TARGETS}); do
    if [[ ! "${removed_targets}" == *"${target}"* ]]; then
      if [[ -z "${targets}" ]]; then
        local targets="${target}"
      else
        local targets="${targets} ${target}"
      fi
    fi
  done
  popd &> /dev/null

  # Convert added items to full targets and add to current
  for target in $(\
      BASE_DIR=${PROJECT_DIR} __projux_normalize_targets ${added}); do
    # Strip pre-package path
    local normalized_target=${target##${PROJECT_TEST_DIR}}
    # Remove any extension
    if [[ -n "${normalized_target##*.}" ]]; then
      normalized_target=${normalized_target%.*}
    fi
    if [[ ! "${targets}" == *"${target}"* ]]; then
      if [[ -z "${targets}" ]]; then
        local targets="${normalized_target}"
      else
        local targets="${targets} ${normalized_target}"
      fi
    fi
  done

  export PROJECT_TEST_TARGETS="${targets}"
}

################################################################################
# Clears default tests.
#
# Clears PROJECT_TEST_TARGETS environment variable
#
# Example:
#   cleartests
################################################################################
function cleartest() {
  local project_name="${PROJECT_NAME}"
  if [[ "${1}" == "-p" ]]; then
    shift
    project_name="${1}"
    shift
  fi

  if [[ "${project_name%%:*}" != "${PROJECT_NAME}" || ! is_dev_local ]]; then
    __projux_tmux_send \
        "$(__projux_default_project_win ${project_name})" "cleartest" $*
    return $?
  fi

  export PROJECT_TEST_TARGETS=""
}

################################################################################
# Gets default run cmd.
#
# REQUIREMENTS: project env vars are properly set (via 'project <name>')
#
# Echos PROJECT_RUN_CMDS environment variable
#
# Examples:
#   getrun                       # get all commands
#   getrun foo                   # Gets cmd labeled with foo::
#   getrun foo --my_flag=+bar    # Gets cmd labeld with foo:: and adds to flag
#
# Args:
#   label: Optional label for run command to return.
################################################################################
function getrun() {
  local project_name="${PROJECT_NAME}"
  if [[ "${1}" == "-p" ]]; then
    shift
    project_name="${1}"
    shift
  fi

  if [[ $# -eq 0 ]]; then
    echo "$(__projux_project_var ${project_name%%:*} PROJECT_RUN_CMDS)"
  else
    local bin_dir=$(__projux_project_var ${project_name%%:*} PROJECT_BIN_DIR)
    echo "${bin_dir}/$(__projux_get_run_cmd ${project_name%%:*} $*)"
  fi
}

################################################################################
# Sets run commands.
#
# REQUIREMENTS: project env vars are properly set (via 'project <name>')
#
# Replaces the PROJECT_RUN_CMDS environment variable with specified
# value.
#
# Example:
#   setrun foo::foo --someflag=some-value bar::bar --otherflag
#
# Args:
#   cmd: Run commands.
################################################################################
function setrun() {
  local project_name="${PROJECT_NAME}"
  if [[ "${1}" == "-p" ]]; then
    shift
    project_name="${1}"
    shift
  fi

  if [[ "${project_name%%:*}" != "${PROJECT_NAME}" || ! is_dev_local ]]; then
    __projux_tmux_send \
        "$(__projux_default_project_win ${project_name})" "setrun" $*
    return $?
  fi

  export PROJECT_RUN_CMDS="$*"
}

################################################################################
# Updates run commands.
#
# REQUIREMENTS: project env vars are properly set (via 'project <name>')
#
# Updates a single run command within the PROJECT_RUN_CMDS environment
# variable.
#
# Example:
#   updaterun foo::foo --someflag=+some-value,-other_value
#
# Args:
#   cmd: Command.
################################################################################
function updaterun() {
  local project_name="${PROJECT_NAME}"
  if [[ "${1}" == "-p" ]]; then
    shift
    project_name="${1}"
    shift
  fi

  if [[ "${project_name%%:*}" != "${PROJECT_NAME}" || ! is_dev_local ]]; then
    __projux_tmux_send \
        "$(__projux_default_project_win ${project_name})" "updaterun" $*
    return $?
  fi

  local run_cmd=""
  # Loop over current run commands looking for things to update
  local skip=0
  for token in $(echo ${PROJECT_RUN_CMDS}); do
    # If start of a command
    if [[ "${token}" == *::* ]]; then
      local skip=0
      local cmd_name=${token%%::*}
      # If command passed as arg then update it
      if [[ "$@" == "${cmd_name}"* ]]; then
        local cmd=$(__projux_get_run_cmd ${project_name%%:*} "$@")
        if [[ -z "${run_cmd}" ]]; then
          local run_cmd="${cmd_name}::${cmd}"
        else
          local run_cmd="${run_cmd} ${cmd_name}::${cmd}"
        fi
        local skip=1
      fi
    fi
    if [[ $skip -eq 0 ]]; then
      if [[ -z "${run_cmd}" ]]; then
        local run_cmd="${token}"
      else
        local run_cmd="${run_cmd} ${token}"
      fi
    fi
  done

  export PROJECT_RUN_CMDS="${run_cmd}"
}

################################################################################
# Clears run cmd.
#
# Clears PROJECT_RUN_CMDS environment variable.
#
# Example:
#   clearrun
################################################################################
function clearrun() {
  local project_name="${PROJECT_NAME}"
  if [[ "${1}" == "-p" ]]; then
    shift
    project_name="${1}"
    shift
  fi

  if [[ "${project_name%%:*}" != "${PROJECT_NAME}" || ! is_dev_local ]]; then
    __projux_tmux_send \
        "$(__projux_default_project_win ${project_name})" "clearrun" $*
    return $?
  fi

  export PROJECT_RUN_CMDS=""
}


################################################################################
# Internal Helper Functions
################################################################################

################################################################################
# Helper function to get run cmd.
#
# Example (cmds=test1::test1 --foo=a, --bar=b test2::test2 --bat=c)
#   # test1 --foo=a,d,e ==bar=b
#   __projux_choose_cmd ${cmds} test1 --foo=+d,+e
#
# Args:
#   $1: Project name.
#   $2: Name of an embedded command with ${cmds}
#   $*: Modifications to default flags
#
# Returns:
#   Full form of embedded run command after flag changes.
################################################################################
function __projux_get_run_cmd() {
  if [[ "${1}" != "${PROJECT_NAME}" ]]; then
    local run_cmds=$(__projux_project_var "${1}" "PROJECT_RUN_CMDS")
  else
    local run_cmds=${PROJECT_RUN_CMDS}
  fi
  shift
  __projux_key_value "${run_cmds}" "$@"
}

################################################################################
# Helper function to select and run a command.
#
# Example (PROJECT_FOO_CMDS=foo::foo --x=a, --y=b bar::bar --z=c)
#   # Runs: 'foo --x=a,d,e'
#   __projux_select_cmd "PROJECT_FOO_CMDS" "FOOING" foo --x=+d,+e
#
# Args:
#   $2: Variable name ('PROJECT_PACKAGE_CMDS', etc).
#   $2: Heading to display ('PACKAGING', 'DEPLOYING', etc).
#   $3: Project name (optional).
#   $4: Name of an embedded command with ${cmds}
#   $*: Modifications to default flags
#
# Returns:
#   0 if success, 1 if failure
################################################################################
function __projux_select_cmd() {
  local var="${1}"
  shift
  local heading="${1}"
  shift
  local project_name="${PROJECT_NAME}"
  if [[ "${1}" == "-p" ]]; then
    shift
    project_name="${1}"
    shift
  fi

  if [[ "${project_name%%:*}" != "${PROJECT_NAME}" || ! is_dev_local ]]; then
    local args="__projux_select_cmd ${var} ${heading} $@"
    __projux_tmux_send "$(__default_project_win ${project_name})" "${args}"
    return $?
  fi

  # evals ${PROJECT_FOO_CMDS-${DEFAULT_PROJECT_FOO_CMDS}}
  local cmds=$(eval "echo \${${var}-\${DEFAULT_${var}}}")
  local cmd=$(__projux_key_value "${cmds}" "$@")

  if [[ -z "${VERBOSE}" || ${VERBOSE} -ne 0 ]]; then
    __projux_print_cmd "${heading}" "${cmd}"
  fi

  if [[ ${DRY_RUN-false} -eq 0 ]]; then
    $cmd
  fi
  return $?
}

################################################################################
# Helper function to execute commands on targets based on file extensions.
#
# All commands are run from the $BASE_DIR and targets must be in subdirectories
# of $BASE_DIR.
#
# Examples:
#   # Run format using clang-format and gofmt
#   PROJECT_INCLUDE_FILTER=make:*.{cc,h}:*.go:*.py \
#   HEADING="FORMATTING" \
#   EXEC_CMDS="cc:h=clang-format <targets>,go=gofmt -w <targets>" \
#   __projux_exec ...
#
# Env Vars:
#   $BASE_DIR: Base dir to run commands from (default is lowest common dir)
#   $EXEC_CMDS: List of comma separated <file_ext>:...<file_ext>=<cmd>;...;<cmd>
#   $OUT_DIR: Output dir to store last_run output.
#   $FILE_TYPE: Set to a specific filetype to use that overrides the
#     INCLUDE_FILTER. This is only used when stdin is piped in order to
#     determine what file type the stdin is assoicated with.
#   $PROJECT_INCLUDE_FILTER:
#   $PROJECT_EXCLUDE_FILTER:
#   $HEADING: Heading to print when VERBOSE used
#   $VERBOSE: True to print what will be run
#   $DRY_RUN: True to only do dry run
#
# Args:
#   $*: Target files and directories (... means recursively) or stdin.
#
# Returns:
#   0 if success, 1 if failure.
################################################################################
function __projux_exec() {
  if [[ -z "${OUT_DIR}" ]]; then
    echo "$(tput setaf 1)ERROR: OUT_DIR not set$(tput sgr0)"
    return 1
  fi

  if [[ ! -d "${OUT_DIR}" ]]; then
    mkdir ${OUT_DIR} &> /dev/null
    if [[ $? -ne 0 ]]; then
      echo "$(tput setaf 1)ERROR: failed to create ${OUT_DIR}$(tput sgr0)"
      return 1
    fi
  fi

  # Stdin passed, process directly
  if [[ ! -t 0 ]]; then
    if [[ -z "${FILE_TYPE}" ]]; then
      echo "$(tput setaf 1)ERROR: FILE_TYPE not set, but stdin used$(tput sgr0)"
      return 1
    fi

    # Change to out dir
    pushd ${OUT_DIR} &> /dev/null
    if [[ $? -gt 0 ]]; then
      echo "$(tput setaf 1)ERROR: Invalid directory ${OUT_DIR}$(tput sgr0)"
      return 1
    fi

    local status=0
    local tmp=${OUT_DIR}/buffer.${FILE_TYPE}
    cat > ${tmp} 2> /dev/null

    # By setting the INCLUDE_FILTER to FILE_TYPE we are forcing the EXEC_CMDS
    # to return the command specific to that FILE_TYPE (if it exists). We are
    # not passing any targets so that we will only get back the command itself.
    # We can then run that command on the stdin. NOTE: EXEC_CMDS is implicitly
    # passed to __project_make_cmd
    local cmd=$(BASE_DIR=${OUT_DIR} \
                INCLUDE_FILTER="*.${FILE_TYPE}" \
                __projux_make_cmd ${tmp})
    if [[ $? -ne 0 || "${cmd}" == *"ERROR"* ]]; then
      echo "${cmd}"
      status=1
    fi

    if [[ $status -eq 0 && -n "${cmd}" ]]; then
      eval "${cmd}" 2>&1 > ${OUT_DIR}/last_run
      status=$?
    fi

    popd &> /dev/null

    # output results
    if [[ $status -eq 0 ]]; then
      cat ${tmp}
    fi

    rm ${tmp}
    return $status
  fi

  # Non-stdin should only be run project host
  local project_host=${PROJECT_HOST-${DEFAULT_PROJECT_HOST}}
  if [[ $(hostname) != "${project_host}" ]]; then
    local msg="ERROR: Not on project host: ${project_host}"
    echo "$(tput setaf 1)${msg}$(tput sgr0)"
    return 1
  fi

  local inc_filter="${PROJECT_INCLUDE_FILTER-${DEFAULT_PROJECT_INCLUDE_FILTER}}"
  local exc_filter="${PROJECT_EXCLUDE_FILTER-${DEFAULT_PROJECT_EXCLUDE_FILTER}}"

  local targets=$(\
      BASE_DIR="" GLOB_IGNORE=${exc_filter}  __projux_normalize_targets "$@")

  if [[ -n "${BASE_DIR}" ]]; then
    local base_dir=${BASE_DIR}
  else
    # get commpon path
    local base_dir=$(__projux_common_path ${targets})
  fi

  # EXEC_CMDS is implicitly passed
  local cmd=$(BASE_DIR=${base_dir} \
              INCLUDE_FILTER=${inc_filter} \
              EXCLUDE_FILTER=${exc_filter} \
              __projux_make_cmd "${targets}")
  if [[ $? -ne 0 || "${cmd}" == *"ERROR"* ]]; then
    echo "${cmd}"
    return 1;
  fi

  # Change to base dir
  pushd "${base_dir}" $> /dev/null
  if [[ $? -gt 0 ]]; then
    echo "$(tput setaf 1)ERROR: Invalid directory ${base_dir}$(tput sgr0)"
    return 1
  fi

  if [[ -z "${VERBOSE}" || ${VERBOSE} -ne 0 ]]; then
    set -f # disable globbing before printing
    __projux_print_cmd "${HEADING}" ${cmd}
    set +f # re-enable
  fi

  local status=0
  if [[ ${DRY_RUN-false} -eq 0 ]]; then
    export PROJECT_LAST_OUT_DIR=${OUT_DIR}
    if [[ -z "${VERBOSE}" || ${VERBOSE} -ne 0 ]]; then
      eval "${cmd}" 2>&1 | tee ${OUT_DIR}/last_run
    else
      eval "${cmd}" 2>&1 > ${OUT_DIR}/last_run
    fi
    local status=$?
  fi

  popd &> /dev/null
  return $status
}

################################################################################
# Helper function to create command string to perform operations on targets
# based on file extensions.
#
# Commands are specified using a CSV of <ext>:...:<ext>=cmd;...cmd values.
# The keywords '<targets>' or '<args>' within a cmd will be replaced by the
# expanded targets or the args as passed.  All commands are run from the
# $BASE_DIR and must be in subdirectories of $BASE_DIR.
#
# Examples:
#   # Recursively run clang-format on *.cc/*.h and gofmt/govet on *.go
#   BASE_DIR=${PROJECT_DIR} \
#   INCLUDE_FILTER=*.{cc,h}:*.go \
#   EXEC_CMDS="\
#       cc:h=clang-format <targets>, \
#       go=gofmt -w <targets>;govet <targets>" \
#   __projux_make_cmd "..."
#
#   # Run lint on make/*.cc/*.h in src dir
#   BASE_DIR=${PROJECT_DIR} \
#   INCLUDE_FILTER={make,*.cc,*.h} \
#   EXEC_CMDS="make:cc:h=mylint <targets>" \
#   __projux_make_cmd "src"
#
# Env Vars:
#   $BASE_DIR: Base directory to run commands relative to
#   $EXEC_CMDS: List of comma separated <file_ext>:...<file_ext>=<cmd>;...;<cmd>
#   $INCLUDE_FILTER: Colon sep list of file patterns to include (*.{c,h}:*.go)
#   $EXCLUDE_FILTER: Colon sep ist of file patterns to exclude (foo.c:bar.go)
#   $SUFFIXES_FILTER: List of comma separated <file_ext>:...<file_ext>=<suffix>
#   $REMOVE_EXTENSIONS: 1 to remove file extensions (useful for tests).
#
# Args:
#   $*: Target files and directories (... means recursively)
#
# Returns:
#   List of commands and associated targets separated by ';'. The returned value
#   can be used with the bash 'exec' command to execute the commands.
################################################################################
function __projux_make_cmd() {
  # Must run from a sub-directory of ${BASE_DIR}
  if [[ "${PWD:0:${#BASE_DIR}}" != "${BASE_DIR}" ]]; then
    echo "$(tput setaf 1)ERROR: Not in subdirectory of ${BASE_DIR}$(tput sgr0)"
    return 1
  fi

  # disable globbing
  set -f

  local exec_cmds=""

  local OLDIFS=$IFS
  local extensions_cmds
  eval "$(__projux_key_value_list kv_list ${EXEC_CMDS})"
  for extensions_cmds in "${kv_list[@]}"; do
    local extensions=${extensions_cmds%%::*}
    extensions=$(echo ${extensions})  # strip spaces
    local cmds=${extensions_cmds#*::}
    cmds=$(echo ${cmds})  # strip spaces
    local cmd

    # Process no-arg and arg only commands
    local updated_cmds=""
    local args=()
    if [[ "${cmds}" == *"<args>"* ]]; then
      # convert args to args relative to base dir
      local arg
      for arg in "$@"; do
        arg="${arg##${BASE_DIR}/}"
        # Strip extensions if requested
        if [[ ${REMOVE_EXTENSIONS} -eq 1 && "${arg}" != *"..." ]]; then
          arg="${arg%.*}"
        fi
        args+=("${arg}")
      done
    fi
    IFS=$';'
    for cmd in ${cmds}; do
      cmd=${cmd/<args>/"${args[@]}"}
      if [[ "${cmd}" == *"<targets>"* ]]; then
        updated_cmds="${updated_cmds};${cmd}"
      else
        exec_cmds="${exec_cmds}; ${cmd}"
      fi
    done
    IFS=$OLDIFS
    cmds="${updated_cmds:1}"  # :1 to skip starting ';'

    # Only need to continue on to process targets if they are used in a command
    if [[ "${cmds}" != *"<targets>"* ]]; then
      continue
    fi

    # Create list of matching targets
    local include_targets=()
    local exclude_targets=()
    local filter
    local ext
    local found=0
    IFS=$':'
    for filter in ${INCLUDE_FILTER}; do
      for ext in ${extensions}; do
        # A bit hacky, but we are trying to find filters that match our
        # extensions. For example, given INCLUDE_FILTER="*.{cc,h}:*.go" and
        # extensions "cc:h" then include_glob="*.{cc,h}". To accomplish this
        # we will first try to match each extension followed by a comma (e.g.
        # 'cc,' and 'h,') against the filter followed by a comma (e.g.
        # '*.{cc,h},' and '*.go,'). In this case 'cc,' will match. We will
        # also try to match each extension followed by a closed brace (e.g.
        # 'cc}' and 'h}') against the filter followed by a comma (e.g.
        # '*.{cc,h},' and '*.go,'). In this case 'h}' will match. These
        # checks ensure that we will match any extension within a filter and
        # only full matches (e.g. 'c' won't accidently match 'cc').
        if [[ "${filter}," =~ "${ext}," || "${filter}," =~ "${ext}}" ]]; then
          local glob_pattern=${filter}
          local suffix=$(__projux_value_for_ext "${ext}" ${SUFFIXES_FILTER})
          if [[ -n "${suffix}" ]]; then
            # This converts a '*.cc' to '*_test.cc'
            glob_pattern="${glob_pattern/\*/*${suffix}}"
          fi
          IFS=$OLDIFS
          # $BASE_DIR implicilty passed
          # Example output: src/foo/*.{c,h} src/bar/*.{c,h}
          include_targets+=(\
              $(GLOB_PATTERN=${glob_pattern} \
                GLOB_IGNORE=${EXCLUDE_FILTER} \
                __projux_expand_targets "$@"))
          IFS=$':'
          found=1
          break
        fi
      done
    done
    for filter in ${EXCLUDE_FILTER}; do
      # Directory based exclusion has already been accounted for via GLOB_IGNORE
      # use above with the INCLUDE_FILTER. We only need to care about cases
      # where a specific file pattern was used along side the include glob.
      for ext in ${extensions}; do
        if [[ "${filter}," =~ "${ext}," || "${filter}," =~ "${ext}}" ]]; then
          IFS=$OLDIFS
          # $BASE_DIR implicilty passed
          # Example output: src/foo/bar.c src/bar/bar.c
          exclude_targets+=(\
              $(GLOB_PATTERN=${filter} __projux_expand_targets "$@"))
          IFS=$':'
          break
        fi
      done
    done
    IFS=$OLDIFS

    if [[ ${#include_targets[@]} -eq 0 ]]; then
      continue
    fi

    # Strip extensions if requested
    if [[ ${REMOVE_EXTENSIONS} -eq 1 ]]; then
      local new_targets=()
      local target
      set +f # enable globbing
      for target in "${include_targets[@]}"; do
        new_targets+=("${target%.*}")
      done
      set -f # disable globbing
      include_targets=${new_targets}
    fi

    # Add commands to run on the given targets
    IFS=$';'
    for cmd in ${cmds}; do
      local ignore=""
      if [[ ${#exclude_targets[@]} -gt 0 ]]; then
        # GLOBIGNORE is used to ignore the patterns for globbing. We build up
        # the pattern to assign to glob ignore here in the variable $ignore
        local target
        for target in ${exclude_targets[@]}; do
          ignore="${ignore}:${target}"
        done
        ignore="GLOBIGNORE=${ignore:1}; "  # :1 to skip over first ':'
      fi

      exec_cmds="${exec_cmds}; ${ignore}${cmd/<targets>/${include_targets[@]}}"
    done
    IFS=$OLDIFS
  done
  IFS=$OLDIFS

  echo "${exec_cmds:2}"  # :2 to skip over '; ' at start of commands

  # re-enable globbing
  set +f
}

################################################################################
# Helper function to recursively expand directories within targets.
#
# Any trailing '...' indicators to target recusive directories will be
# removed.
#
# Example (assuming directory structure a/b/c, a/b/d, e):
#   # Returns: a/b/c/*.{cc,h} a/b/d/*.{cc,h} x.txt e/*.{cc,h}
#   GLOB_PATTERN=*.{cc,h} __projux_expand_targets a/... x.txt e
#
# Env Vars:
#   $BASE_DIR: Base directory to return targets relative to
#   $GLOB_PATTERN: Glob pattern to add to directories (e.g *.go, *.{c,h}, etc)
#   $GLOB_IGNORE: Colon sep list of files/dirs to ignore (e.g. *backup/*:*tmp/*)
#
# Args:
#   $*: Named targets to search for relative to base src/test dir. Targets
#       can be directories or they can be specific files (in which case their
#       extensions must match the glob pattern). Targets can have absolute
#       paths or paths relative to the current directory.
#
# Returns:
#   List of targets with dirs relative to ${BASE_DIR}
################################################################################
function __projux_expand_targets() {
  # The extensions variable contains a comma separated list of extensions where
  # each extension is guaranteed to end in a comma. This is a hack, but we will
  # look for each file extension followed by a comma in the list to ensure a
  # match. For example, if GLOB_PATTERN=*.{c,h} then extensions="c,h,". If
  # passed foo.c then we will compare "c,h," =~ "c," to ensure it's a valid
  # file.
  if [[ -n "${GLOB_PATTERN}" ]]; then
    local glob="/${GLOB_PATTERN}"
    if [[ "${GLOB_PATTERN}" =~ "{" ]]; then
      # Pattern is of the form "*.{c,h}"
      local extensions="${GLOB_PATTERN##*\{}" # remove "*.{" from  "*.{c,h}"
      extensions="${extensions/\}/,}" # replace '}' with ',' resulting in "c,h,"
    else
      # Pattern is of the form "*.scala"
      local extensions="${GLOB_PATTERN##*\.},"  # remove "*." and add ','
    fi
  else
    local glob=""
    local extensions=""
  fi

  local expanded=()
  local target
  for target in "$@"; do
    if [[ "${target:0:1}" != "/" ]]; then
      target=${PWD}/${target}
    fi
    # strip any traling '/'
    if [[ "${target:${#target}-1}" == "/" ]]; then
      target=${target%/*}
    fi

    if [[ "${target}" != *"/..." ]]; then
      # Check for ignored targets ($GLOB_IGNORE implicitly passed)
      if __projux_is_target_excluded "${target}"; then
        continue
      fi

      if [[ -d "${target}" ]]; then
        # Directory, so just glob the extensions (e.g. foo/*.{c,h})
        if ! __projux_files_exist "${target}" "${glob}"; then
          continue
        fi
        target="${target}${glob}"
      elif [[ -n "${extensions}" && \
               ! "${extensions}" =~ "${target##*.}," ]]; then
        # File passed that does not match requested extensions
        continue
      fi
      expanded+=("${target##${BASE_DIR}/}")
    else
      target=${target///.../}  # remove /... recursive indicator

      if [[ -d "${target}" ]]; then
        local dir
        for dir in $(find ${target} -type d); do
          # Check for ignored targets ($GLOB_IGNORE implicitly passed)
          if __projux_is_target_excluded "${dir}"; then
            continue
          fi

          # Directory, so just glob the extensions (e.g. foo/*.{c,h})
          if ! __projux_files_exist "${dir}" "${glob}"; then
            continue
          fi
          local sub_target="${dir}${glob}"

          expanded+=("${sub_target##${BASE_DIR}/}")
        done
      elif [[ -n "${extensions}" && \
               ! "${extensions}" =~ "${target##*.}," ]]; then
        # File passed that does not match requested extensions
        continue
      else
        # Check for ignored targets ($GLOB_IGNORE implicitly passed)
        if __projux_is_target_excluded "${target}"; then
          continue
        fi

        expanded+=("${target##${BASE_DIR}/}")
      fi
    fi
  done

  echo "${expanded[*]}"
}

################################################################################
# Helper function to expand package directories to include src/test dirs.
#
# Directories to include are specified with the first params:
#   $1 == 1   PROJECT_SRC_DIR
#   $1 == 2   PROJECT_TEST_DIR
#   $1 == 3   PROJECT_SRC_DIR and PROJECT_TEST_DIR (if different else only one)
#
# Example
#   # Env Vars
#   #   PROJECT_PKGS="a b"
#   #   PROJECT_SRC_DIR=${PROJECT_DIR}/src
#   # Returns:
#   #   ${PROJECT_SRC_DIR}/a ${PROJECT_SRC_DIR}/b
#   __projux_expand_pkgs 1
#
# Env Vars
#   $PROJECT_SRC_DIR: project source dir
#   $PROJECT_TEST_DIR: project test dir
#
# Args:
#   $1: 1 - include src dirs, 2 - include test dirs, 3 include both
#
# Returns:
#   Space separated list of expanded dirs
################################################################################
function __projux_expand_pkgs() {
  local dirs=()
  if [[ $1 -eq 1 || "${PROJECT_SRC_DIR}" == "${PROJECT_TEST_DIR}" ]]; then
    dirs+=("${PROJECT_SRC_DIR}")
  elif [[ $1 -eq 2 ]]; then
    dirs+=("${PROJECT_TEST_DIR}")
  else
    dirs+=("${PROJECT_SRC_DIR}")
    dirs+=("${PROJECT_TEST_DIR}")
  fi

  local expanded=()
  for d in "${dirs[@]}"; do
    local pkgs=(${PROJECT_PKGS})
    for p in "${pkgs[@]}"; do
      expanded+=("${d}/${p}/...")
    done
  done

  echo "${expanded[*]}"
}

################################################################################
# Helper function to find common path.
#
# Example:
#   # Returns: /foo/bar
#   __projux_common_path /foo/bar/baz /foo/bar/bat /foo/bar/hat/cat
#
#
# Args:
#   $1: Space separated list of targets.
#
# Returns:
#   Common path among targets
################################################################################
function __projux_common_path() {
  if [[ $# -lt 2 ]]; then
    if [[ -d "${1}" ]]; then
      local common_path=${1}
    else
      local common_path=${1%/*}
    fi
  else
    local common_path=$(\
        printf "%s\n" "$@" | \
        sed -e 's,$,/,;1{h;d;}' -e 'G;s,\(.*/\).*\n\1.*,\1,;h;$!d;s,/$,,')
  fi
  echo ${common_path}
}

################################################################################
# Helper function to simplify paths.
#
# Example:
#   # Returns: b/d
#   BASE_DIR=/a __projux_normalize_path /a/b/c/../d
#
# Env Vars:
#   $BASE_DIR - base directory to return path relative to
#
# Args:
#   $1: Full target path.
#
# Returns:
#   Normalized path.
################################################################################
function __projux_normalize_path() {
  # TODO(mdreves): Replace with non-python implementation
  target=$( \
      python -c "import os,sys; print os.path.realpath(sys.argv[1])" "${1}")
  if [[ $? -gt 0 ]]; then
    target=${1}
  fi
  if [[ "${BASE_DIR}" == "" || "${target}" != "${BASE_DIR}"*  ]]; then
    echo "${target}"
  else
    echo "${target:${#BASE_DIR} + 1}"
  fi
}

################################################################################
# Helper function to normalize a list of target names used within a project.
#
# Example (assuming current dir is ${BASE_DIR}/start/here):
#   # Returns: start/here/foo start/bar start/baz:all start/here:target
#   __projux_normalize_targets foo ../bar ../baz:all :target
#
# Env Vars:
#   $BASE_DIR - base directory to normalize targets relative to
#   $GLOB_IGNORE: Colon sep list of files/dirs to ignore (*tmp/*:*backup/*)
#
# Args:
#   $*: Named targets to search for relative to current dir.
#
# Returns:
#   List of targets with dirs relative to ${BASE_DIR}
################################################################################
function __projux_normalize_targets() {
  base_dir="${BASE_DIR}"
  local matches=()
  for arg in "$@"; do
    local target="${arg}"
    if [[ "${arg}" != "/"* ]]; then
      # Relative path may be used, need to find real path
      local fullpath="${PWD}/${arg}"
      local parent_dir="${fullpath%/*}"
      local suffix="${arg##*/}"
      if [[ "${suffix}" == "." || "${suffix}" == ".." ]]; then
        local parent_dir="${parent_dir}/${suffix}"
        local suffix=""
      fi
      local realpath=$(__projux_normalize_path "${parent_dir}")
      if [[ "${suffix}" == ":"* ]]; then
        target="${base_dir}${realpath}${suffix}"
      elif [[ -z "${suffix}" ]]; then
        target="${base_dir}${realpath}"
      else
        target="${base_dir}${realpath}/${suffix}"
      fi
    fi
    if [[ "${target}" == "${base_dir}/" || "${target}" == "${base_dir}" ]]; then
      matches+=(".")
    else
      if [[ -z "${base_dir}" ]]; then
        match="${target}"
      else
        match="${target:${#base_dir} + 1}"
      fi
      # Skip matches that should be excluded
      if ! __projux_is_target_excluded "${match}"; then
        matches+=("${match}")
      fi
    fi
  done

  echo "${matches[*]}"
}

################################################################################
# Helper function to check if target excluded.
#
# Env Vars:
#   $GLOB_IGNORE: Colon sep list of files/dirs to ignore (*tmp/*:*backup/*)
#
# Args:
#   $1: Target
#
# Returns:
#   0 excluded, 1 not excluded
################################################################################
function __projux_is_target_excluded() {
  local excluded=1
  local exclude=""
  local remaining="${GLOB_IGNORE}"
  while [[ -n "${remaining}" && "${exclude}" != "${remaining}" ]]; do
    exclude="${remaining%%:*}"
    remaining="${remaining#*:}"
    if [[ "${1}" == ${exclude} || "${1}/" == ${exclude} ]]; then
      excluded=0
      break
    fi
  done
  return $excluded
}

################################################################################
# Helper function to check if files exist that match glob.
#
# Example:
#   # Return 0 if *.{c,h} in src/foo directory
#   __projux_files_exist src/foo "*.{c,h}"
#
# Args:
#   $1: Target dir.
#   $2: Glob pattern.
#
# Returns:
#   0 files exist, 1 no files exist
################################################################################
function __projux_files_exist() {
  local extensions=${2##*\.}  # strip '*.' from '*.xx'
  local extensions=${extensions##*{}  # strip '{' from '{c,h}'
  extensions=${extensions%%\}*}  # strip '}' from 'c,h}'
  OLDIFS=$IFS
  IFS=$','
  local patterns=""
  local ext
  for ext in ${extensions}; do
    patterns="${patterns} -o -name '*.${ext}'"
  done
  IFS=$OLDIFS
  patterns=${patterns:4}  # strip starting ' -o '
  # Use quit so we cut out early so the find command is cheap
  cmd="find ${1} -maxdepth 1 ${patterns} -print -quit"
  local result=$(eval $cmd)
  if [[ -n "${result}" ]]; then
    return 0
  else
    return 1
  fi
}

################################################################################
# Helper function to create subdir of target dir.
#
# Args:
#   $1: Subdir to create.
#
# Returns:
#   0 success, 1 failure
################################################################################
function __projux_create_target_subdir() {
  if [[ -z "${PROJECT_TARGET_DIR}" ]]; then
    echo "$(tput setaf 1)ERROR: PROJECT_TARGET_DIR not set$(tput sgr0)"
    return 1
  fi
  if [[ -z "${1}" ]]; then return 1; fi
  if [[ -d "${PROJECT_TARGET_DIR}/${1}" ]]; then return 0; fi

  mkdir ${PROJECT_TARGET_DIR} &> /dev/null
  mkdir ${PROJECT_TARGET_DIR}/${1} &> /dev/null
  if [[ $? -ne 0 ]]; then
    local msg="ERROR: failed to create ${PROJECT_TARGET_DIR}/${1}"
    echo "$(tput setaf 1)${msg}$(tput sgr0)"
    return 1
  fi
  return 0
}

################################################################################
# Prints command.
#
# HEADING -------------------------------
# PWD: .....
# CMD: .....
# ---------------------------------------
#
# Args:
#   $1: heading
#   $2: raw command
#   $3*: targets
################################################################################
function __projux_print_cmd() {
local sep="\
--------------------------------------------------------------------------------"
  echo "$(tput setaf 2)${1} ${sep:0:${#sep}-${#1}-1}"
  shift
  local pwd=${PWD/${HOME}/"~"}
  echo "PWD: ${pwd}"
  local padding="                                        "
  local next="CMD: ${1}"
  shift
  local state=2 # 1 next value is command, 2 first value after command, 0 normal
  local t
  for target in "$@"; do
    target=$(echo ${target}) # trim spaces
    if [[ "${target:0:1}" == "|" ]]; then
      # piped output
      if [[ "${next:${#next}-1}" == "\\" ]]; then
        next="${next:0:${#next}-2} ${target}"
      else
        next="${next} ${target}"
      fi
      state=3
    elif [[ $state -eq 1 ]]; then
      echo "${next}"
      next="     ${target}"
      state=2
    elif [[ ! "${target}" == */* ]]; then
      # target part of command, just add to current and then get next arg
      next="${next} ${target}"
      continue
    elif [[ $state -eq 3 ]]; then
      next="${next} ${target}"
      if [[ "${target}" == *";" ]]; then
        state=1
      fi
    elif [[ $state -eq 2 ]]; then
      if [[ "${target}" == *";" ]]; then
        state=1
      else
        state=0
      fi
      if [[ $((${#next} + ${#target})) -lt 76 ]]; then
        # Put first target on same line as command
        local offset=${#next}
        local next="${next} ${target} \\"
      else
        echo "${next} \\"
        local next="${target}"
        local offset=8
      fi
    else
      echo "${next}"
      if [[ "${target}" == *";" ]]; then
        state=1
      fi
      next="${padding:0:${offset}} ${target} \\"
    fi
  done
  if [[ "${next:${#next}-1}" == "\\" ]]; then
    echo "${next:0:${#next}-2}"
  else
    echo "${next}"
  fi
  echo "${sep}$(tput sgr0)"
}


################################################################################
# Help
################################################################################

function __projux_print_cmds() {
  echo "format [-p <proj...>] [<target>]      - formats target"
  echo "lint [-p <proj...>] [<target>]        - lints target"
  echo "build [-p <proj...>] [<targ>|clean]   - build target"
  echo "test [-p <proj...>] [<target>]        - runs test target"
  echo "coverage [-p <proj...>] [<target>]    - runs code coverage"
  echo "run [-p <proj...>] [<prog>]           - runs program"
  echo "clean [-p <proj...>]                  - clears project temp files"
  echo "package [-p <proj...>]                - packages project output"
  echo "deploy [-p <proj...>]                 - deploys project output"
  echo "gendocs [-p <proj...>]                - generates project docs"
  echo "search [-p <proj...>] <tags>          - searches code for tags"
  echo "sanity [-p <proj...>]                 - runs project sanity check"
  echo "share [-p <proj...>] <prog>           - copy program to ~/Public, etc"
  echo "geterrors [-p <proj...>] [lint|...]   - gets errors of prev lint, ..."
  echo "geturl [-p <proj...>] [review|bug|..] - gets url for review, bug, ..."
  echo "open{build|test|coverage|bug|review}  - open url for build/test..."
  echo "get/set/update/cleartest [+-]<target> - modify PROJECT_TEST_TARGETS"
  echo "get/set/update/clearrun [+-]<flags>   - modify PROJECT_RUN_CMDS"
}
